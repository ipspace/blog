{
   "comments": [
      {
         "date": "02 March 2021 07:36",
         "html": "<p>This is what you will end up by teaching networking to coders.</p>\n\n<p>Unless they get this basic point that they need to create some abstraction layer for interaction to simplify the consumption and breaking everything down to smallest of objects for programmability, flexibility and extensibility in automation/coding terms doesn&#39;t mean everyone should go down to that level when putting this to life.</p>\n\n<p>Though network engineers learning automation are no different either unless they are doing it for full time to taste the real flavors of it</p>\n\n<p>and at some point I just hope that people will stop believing in those both sets of unicorns and rather invest into simple Operational model which would bring them together and make it work while keeping it simple.</p>\n",
         "id": "431",
         "name": " A Network Artist",
         "pub": "2021-03-02T07:36:14",
         "type": "comment"
      },
      {
         "date": "02 March 2021 10:48",
         "html": "<p>ACI took a departure from the classic CLI-driven loosely-coupled network of boxes that&#39;s been predominant in most networks for the past 20 years. \nInstead, ACI is architected as a declarative controller front-ending a number of switches. You tell the controller what you want, and it ensures your desired configuration is rendered on the appropriate switches. </p>\n\n<p>If the complexity of configuring and operating a classic loosely-coupled network of boxes is expressed as O(n*m) where n represents the number of features and m the number of boxes, then I would say ACI is expressed as O(n). It removes the number of boxes variables from the equation. </p>\n\n<p>To do that, ACI does model everything (VRFs, subnets, interfaces, etc.) as an object and creates relations between objects. Why does this matter? With this model, you can configure 1000 interfaces across 50 switches with just two objects. Imagine you want all interfaces to have LLDP enabled tx/rx, CDP disabled, and accept endpoints in VLANs 100-200: you bind the VLAN pool to the interface selector, and you bind the interface selector to a switch selector. Done. OK - there are a few intermediate objects in the picture (physical domain, interface policy group and AAEP) but at the end of the day the philosophy is to build reusable building blocks you can apply to an arbitrary large number of objects. This lends itself quite well to pattern-based data center network architectures. One of ACI&#39;s strength is that everything (all CRUD operations) uses a well-documented REST API. The CLI on APIC (ACI&#39;s controller) is nothing but a client of that REST API. The API allowed us to build modules for popular configuration management and infrastructure provisioning tools such as Ansible and Terraform in record times. We can also easily document objects that have been modified or deprecated between releases.\nWe published a Python SDK that auto-generates code based on JSON payloads exchanged between the web client and APIC itself. </p>\n\n<p>The concept of tenants coupled with the REST API tremendously simplifies A/B testing, versioning (it&#39;s very simple to roll back to a functioning version of the configuration) and role-based access-control (RBAC).</p>\n\n<p>But I feel this isn&#39;t immediately germane to the actual topic. The OP appears a bit torn between not being able to do things like he&#39;s always done them. \nFor instance he writs &quot;Do things right for the first time or do it several times by trial and error. Logical structure and consistency is hard&quot;. I don&#39;t know if I agree that logical structure and consistency are &quot;hard&quot;. \nI would say they are critical in building systems that scale while remaining simple. Certainly not something that is unique to ACI. \nOn the same topic, we read &quot;You need huge amount of config structure and feature understanding and planning&quot;. Isn&#39;t that applicable to most fields in engineering, at least if you expect a positive or predictible outcome to a project?</p>\n\n<p>Another comment &quot;Most options are best to just ignore in the first round&quot; caught my attention ==&gt; precisely. Particularly in recent versions, the intention is for the GUI to present default values that work for most people.\nI think the OP actually gets the philosophy of ACI. At the end of his article, he writes &quot;you may want to standardize and simplify your connectivity and services before putting it all in ACI. Which is only a good thing.&quot;</p>\n\n<p>ACI can come across as kick in the anthill that is traditional CLI-driven loosely-couple networking of boxes. However, ACI&#39;s intent is not to alienate classic networkers. The GUI is constantly improved and simplified. There is a NxOS-like CLI if you really want to use the CLI. More day-2 capabilities are built either directly in APIC or in adjacent platforms.</p>\n\n<p>This being written, you will probably reap the most benefits through automation. And that requires proper planning, and the adoption of a new skillset. I have seen CLI-ninjas converted to Ansible and Terraform that are now handling infrastructure as code. And they&#39;re not going back.</p>\n",
         "id": "432",
         "name": " Chris Paggen",
         "pub": "2021-03-02T10:48:34",
         "type": "comment"
      }
   ],
   "count": 2,
   "type": "post",
   "url": "2021/03/rant-cisco-aci-complexity.html"
}
