{
   "comments": [
      {
         "comments": [
            {
               "date": "24 November 2021 08:21",
               "html": "<p>Yeah, that&#39;s another huge can of worms. Unless you can do policing per interface you&#39;re always open to a nasty DoS attack.</p>\n\n<p>Years ago it was trivial to kill box-wide ARP handling on a GRS - policer would kick in (protecting the CPU), but nobody would get their ARP replies because most requests were dropped, eventually resulting in loss of service.</p>\n",
               "id": "869",
               "name": "Ivan Pepelnjak",
               "pub": "2021-11-24T08:21:05",
               "ref": "865",
               "type": "comment"
            }
         ],
         "date": "23 November 2021 08:02",
         "html": "<p>Junos used to spawn a dedicated thread only if the precision-timers knob (sub-15ms hold time) was applied, now I think it is baked in by default.  Design sanity is good but I think it&#39;s still a trivial job to choke keepalives..on any vendor platform not properly protected.  If there occurs a mega-failure someday it will probably be related to this.  Even the processes meant to protect systems (policers) can also smother it.</p>\n",
         "id": "865",
         "name": " Jeff Behrns",
         "pub": "2021-11-23T20:02:17",
         "type": "comment"
      },
      {
         "comments": [
            {
               "date": "24 November 2021 08:22",
               "html": "<p>Thanks for the feedback - will add to the article. Would you happen to be aware of scale-out implementations (example: multiple threads computing updates in parallel)? It would be nice to add a few examples in that category.</p>\n",
               "id": "870",
               "name": "Ivan Pepelnjak",
               "pub": "2021-11-24T08:22:45",
               "ref": "866",
               "type": "comment"
            }
         ],
         "date": "23 November 2021 08:31",
         "html": "<p>Ivan - all modern routing protocols implementations are multi-threaded, with a minimum separation of adj handeling, route calculations and update generation. Note - writing multi-threaded code for complex tasks is a non trivial exercise (you could search for thread safety and similar artifacts and what happens when not implemented correctly). Moving to a multi-threaded code in early 2010s resulted in a multi-release (year) effort and 100s of related bugs all around.\nFYI non preemptive is usually called &ldquo;run to completion&rdquo;</p>\n",
         "id": "866",
         "name": " JeffT ",
         "pub": "2021-11-23T20:31:27",
         "type": "comment"
      },
      {
         "comments": [
            {
               "date": "24 November 2021 08:36",
               "html": "<p>Thanks for the link. Looks like they went down the same path as FRR - splitting the routing protocol functionality into independent threads along the lines of the comment by JeffT.</p>\n\n<p>Couldn&#39;t figure out from the article whether they implemented anything beyond that, for example a scale-out architecture with parallel threads handling (for example) outbound updates.</p>\n",
               "id": "871",
               "name": "Ivan Pepelnjak",
               "pub": "2021-11-24T08:36:32",
               "ref": "868",
               "type": "comment"
            }
         ],
         "date": "24 November 2021 03:21",
         "html": "<p>I found this paper released from Facebook fairly interesting. They do mention the creation of their own standards based BGP agent written in C++. I found it interesting they compared the performance of BIRD/QUAGGA with their own implementation. The paper also mentions Facebook&#39;s approach to ASN reuse with BGP confederations, spine pods and hierarchical per POD ipv6 prefix suppression. Pretty interesting approach to yet another BGP use case in the DC.</p>\n\n<p>An excerpt from their paper:</p>\n\n<p>&quot;Our implementation employs multiple system threads, such as the\npeer thread and RIB thread, to leverage the multi-core CPU.\nThe peer thread maintains the BGP state machine for each\npeer and handles parsing, serializing, sending, and receiving\nBGP messages over TCP sockets.&quot;</p>\n\n<p>https://research.fb.com/wp-content/uploads/2021/03/Running-BGP-in-Data-Centers-at-Scale_final.pdf</p>\n",
         "id": "868",
         "name": " Mario",
         "pub": "2021-11-24T03:21:31",
         "type": "comment"
      },
      {
         "date": "24 November 2021 06:09",
         "html": "<p>Modern OSes and hypervisor can have fractional virtual CPUs. Your mentioned limitations on one thread per CPU core is a kind of problem slowly fading away. So when there is I/O blocking another thread can be scheduled on the same CPU core in modern systems. \nWith real processes you do not have this problem for ages, since multiple processes could be easily scheduled in a single CPU.</p>\n\n<p>However, process isolation is not done as good on Unix/Linux as on VMS or ESA. So they had to invent containers. I did not need such tricks on my VAX/VMS already in 1987. I had proper isolation and full resource allocation control. You could also have hard real-time systems on VAXELN. I also used QNX with nicely isolated, robust processes already in the 80s. It was a pity when Cisco dropped QNX from IOS XR...</p>\n\n<p>IBM has had virtual fractional CPU cores already for decades, but people are usually not willing to pay for good quality engineering... :-)</p>\n",
         "id": "873",
         "name": "Bela Varkonyi",
         "pub": "2021-11-24T18:09:57",
         "type": "comment"
      }
   ],
   "count": 4,
   "type": "post",
   "url": "2021/11/multi-threaded-routing-daemons.html"
}
