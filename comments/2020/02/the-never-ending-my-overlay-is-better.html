<div class="comments post" id="comments">
  <h4>8 comments:</h4>
  <div class="comments-content">
    <div class="comment-thread">
        <ol>
      <div>
        <li class="comment" id="1326034203624673405">
          <div class="comment-block">
            <div class="comment-header">
              <cite class="user"><a href="https://www.blogger.com/profile/06074343110093815035" rel="nofollow">Piotr Jablonski</a></cite>
              <span class="datetime secondary-text">
                <a rel="nofollow" id="c1326034203624673405" href="#1326034203624673405">18 February 2020 22:55</a>
              </span>
            </div>
            <div class="comment-content">Thank you, Ivan, for this enormous effort of discussion over the years! I perceive it as a good step in technology development. :)<br /><br />We can&#39;t resist broken wheels because in that sense every protocol and solution is broken. Is LISP a cache-based mechanism? Yes, but the control-plane or controls in the app can tame it. Ok, let&#39;s use something else. OTV? The end to end loop can kill it. Just a few supported HW causes still too large xSTP domains. VXLAN? Without the control-plane, there is a flood and learn behaviour, limited multihoming. EVPN? The best if not spanning L2. Otherwise, detection of L2 data-plane loops can also cause a headache. Don&#39;t use overlays and back to spanning-tree? Still, with these limitations, I would prefer overlays for several reasons.<br /><br />A generation by generation next broken wheels are giving more options for ubiquitous applications. It doesn&#39;t mean that networking is simpler. The other way around, it is way more complicated! Today we can have three embedded VXLAN overlays at the same time like VM based K8s Flannel over host-based NSX VXLAN over the access switch EVPN VXLAN. Why? Because three different departments can take care of their parts of the infrastructure. Is it good or bad? It depends. As always, there are tradeoffs. In my opinion, as to the network architects, we should proactively reach business, application and developers&#39; levels to ask for their needs, to get sync with them, to educate each other and try to work out a subjectively right solution. We don&#39;t need to afraid of broken solutions. We should be afraid of living in silos. Then a waste of time may happen when developers reinvent VLANs with the same broken story we already had.</div>
          </div>
        </li>
      </div>
      <div>
        <li class="comment" id="6413030713547383397">
          <div class="comment-block">
            <div class="comment-header">
              <cite class="user"><a href="https://www.blogger.com/profile/07267516785767923381" rel="nofollow">jsicuran</a></cite>
              <span class="datetime secondary-text">
                <a rel="nofollow" id="c6413030713547383397" href="#6413030713547383397">19 February 2020 02:18</a>
              </span>
            </div>
            <div class="comment-content">Ivan, this is the quote of the year!!!   &quot;IT seems to be one of the few areas where we allow people to build sandcastles and ignore the tides, and then blame someone else when the water inevitable arrives.&quot;  And it rhymes.....</div>
          </div>
        </li>
      </div>
      <div>
        <li class="comment" id="7275184994448981307">
          <div class="comment-block">
            <div class="comment-header">
              <cite class="user"><a href="https://www.blogger.com/profile/12788603393681012943" rel="nofollow">krisiasty</a></cite>
              <span class="datetime secondary-text">
                <a rel="nofollow" id="c7275184994448981307" href="#7275184994448981307">19 February 2020 23:21</a>
              </span>
            </div>
            <div class="comment-content">If only we could finally start solving problems where they really exist (poor app/system design?) instead building tons of workarounds...</div>
              <div class="comment-replies">
                <div class="comment-thread inline-thread">
                  <span class="thread-count"><a>Replies</a></span>
                    <ol>
      <div>
        <li class="comment" id="8713518778394454402">
          <div class="comment-block">
            <div class="comment-header">
              <cite class="user"><a href="https://www.blogger.com/profile/13457151406311272386" rel="nofollow">Ivan Pepelnjak</a></cite>
              <span class="datetime secondary-text">
                <a rel="nofollow" id="c8713518778394454402" href="#8713518778394454402">20 February 2020 06:52</a>
              </span>
            </div>
            <div class="comment-content">Won&#39;t happen anytime soon. Whole economies are making tons of money off customer gullibility and workarounds.</div>
          </div>
        </li>
      </div>
      <div>
        <li class="comment" id="734680899206756328">
          <div class="comment-block">
            <div class="comment-header">
              <cite class="user"><a href="https://www.blogger.com/profile/08145976368034085427" rel="nofollow">Victor Zakharyev</a></cite>
              <span class="datetime secondary-text">
                <a rel="nofollow" id="c734680899206756328" href="#734680899206756328">21 February 2020 23:27</a>
              </span>
            </div>
            <div class="comment-content">at least try to separate security segregation from network designs. All the sudden half (more?) needs to build an overlay falls off the requirements table.</div>
          </div>
        </li>
      </div>
  </ol>

                </div>
              </div>
          </div>
        </li>
      </div>
      <div>
        <li class="comment" id="8192282388036189012">
          <div class="comment-block">
            <div class="comment-header">
              <cite class="user"><a href="https://www.blogger.com/profile/03172563417086934763" rel="nofollow">Steve Chalmers</a></cite>
              <span class="datetime secondary-text">
                <a rel="nofollow" id="c8192282388036189012" href="#8192282388036189012">20 February 2020 11:34</a>
              </span>
            </div>
            <div class="comment-content">With a blank sheet of paper, of course, the correct answer is that a work queue in an application shard is given an identity when it is created, and those application shards allowed to send to that work queue are given a capability (in the capabilities architecture of the 1970s sense) to that queue.  Part of instantiating a particular application shard in a particular place is updating whatever forwarding tables are necessary.<br /><br />The concept of overlay then becomes simply one of application naming.  The concept of underlay becomes one of moving payload from authorized sender-applications to application-receive-queues.  And the concept of containers, VMs, OS instances, hypervisors, or anything else having any role in the data plane becomes an implementation choice inferior to simply giving the application direct access.<br /><br />Who will get this to critical mass and in what decade?  Who knows?  But the status quo is broken, and we all know it.</div>
          </div>
        </li>
      </div>
      <div>
        <li class="comment" id="6708029753249855372">
          <div class="comment-block">
            <div class="comment-header">
              <cite class="user"><a href="https://www.blogger.com/profile/16768554528901017543" rel="nofollow">Unknown</a></cite>
              <span class="datetime secondary-text">
                <a rel="nofollow" id="c6708029753249855372" href="#6708029753249855372">23 February 2020 19:11</a>
              </span>
            </div>
            <div class="comment-content">That Martin is now at a VC, looking for &quot;powerful, disruptive ideas often were once bad ideas&quot;, more than explains his reaction ...</div>
          </div>
        </li>
      </div>
      <div>
        <li class="comment" id="7486771912149117949">
          <div class="comment-block">
            <div class="comment-header">
              <cite class="user"><a href="https://www.blogger.com/profile/07985346761439657130" rel="nofollow">Bela</a></cite>
              <span class="datetime secondary-text">
                <a rel="nofollow" id="c7486771912149117949" href="#7486771912149117949">07 March 2020 12:43</a>
              </span>
            </div>
            <div class="comment-content">LISP is incomplete and not perfect and cannot make wonders. However, its latest variant is the only hybrid push/pull routing protocol that is available commercially on a large scale and also in reasonable open source implementations. Without enough flexibility you cannot build a good generic solution. Exclusively push or poll architectures have very strong limitations. <br />There are some outstanding issues with LISP, such as selective subscription and cache management by external applications (so you could fit into the TCAM resources even when you have policy based routing).<br />If you need &quot;seamless&quot; mobility, still LISP is your best friend. We could achive below 5 ms vertical handovers and failover switching in simple scenarios. But you really have to understand what is going under the hood for this. Large scale testing is still an open issue.<br />Global mobility with BGP has no chance to come to that performance level. Even with significant money incentives, the best BGP experts could not fine tune to that handover or failover speed. A few hundred ms was their best result.<br />You always have to make compromises, but if you do not have the toolsets to express your policies, then you will have no success. In LISP at least we have some chance to further improve. <br />Without active probing you cannot have a reasonable assurance that you would be able to forward your packets. But even probing has some time expiration, so at the time you are actually sending, the situation might be already different. You cannot avoid backholing perfectly...<br />In most cases, we have excess bandwidth, so critical services could use simulcast on independent paths. This is the way, how radar surveillance and air traffic control voice works. But classical best stream selection has its limits, so we have to move to packet by packet deduplication or combination (network coding, etc.). It is not without challenges, but it could give a reasonable improvement, since the probability of really receiving your packet will increase significantly. It has a price in resource consumption, but in some cases you are willing to pay for that...<br /><br /><br /></div>
          </div>
        </li>
      </div>
  </ol>

    </div>
  </div>
</div>
