<div class="comments post" id="comments">
  <h4>15 comments:</h4>
  <div class="comments-content">
    <div class="comment-thread">
        <ol>
      <div>
        <li class="comment" id="3016653319027280364">
          <!--
          <div class="avatar-image-container">
            <img src="https://resources.blogblog.com/img/blank.gif">
          </div>
          -->
          <div class="comment-block">
            <div class="comment-header">
              <cite class="user"><a href="None" rel="nofollow">Petr Lapukhov</a></cite>
              <span class="datetime secondary-text">
                <a rel="nofollow" id="c3016653319027280364" href="#3016653319027280364">02 August 2010 17:26</a>
              </span>
            </div>
            <div class="comment-content">Why you always blog that stuff the day I have to leave somewhere? ;) A quick comment on the loops in 802.1aq. The TTL field is helpful to alleviate the *orwarding plane* loops, which are normally result of inconsistent FIB states among the forwarders. Control-Plane loops are not possible with a *single area* link-state routing domain in stable state, only during the moments of re-convergence. Hower, during reconvergence those are more of forwarding plane loops, than control plane. <br /><br />Based on control-plane being loop free once it converged, all paths in a stable domain are loop-free by the virtue of the routing protocol that created them. However, unstable domain will surely create flooding problems, unless they implement some special ordered FIB programming to overcome transient loops.</div>
          </div>
        </li>
      </div>
      <div>
        <li class="comment" id="1042199070323578400">
          <!--
          <div class="avatar-image-container">
            <img src="https://resources.blogblog.com/img/blank.gif">
          </div>
          -->
          <div class="comment-block">
            <div class="comment-header">
              <cite class="user"><a href="None" rel="nofollow">Ivan Pepelnjak</a></cite>
              <span class="datetime secondary-text">
                <a rel="nofollow" id="c1042199070323578400" href="#1042199070323578400">03 August 2010 09:45</a>
              </span>
            </div>
            <div class="comment-content">Let&#39;s make your comments more precise:<br /><br />* Loops are always a forwarding-plane phenomena (usually generated by control plane).<br />* Permanent control-plane-generated loops are not possible with a bug-less single area link-state routing domain.<br />* Temporary loops could arise during the network convergence phase.<br /><br />Temporary loops are a fact of life in a distributed forwarding network with asynchronous computation. The question is: how do you detect them and deal with them and whether they affect the network performance.<br /><br />It&#39;s impossible for an outsider to evaluate this question in the 802.1aq domain, as the drafts are well-hidden behind the paywall.</div>
          </div>
        </li>
      </div>
      <div>
        <li class="comment" id="1867737192590461015">
          <!--
          <div class="avatar-image-container">
            <img src="https://resources.blogblog.com/img/blank.gif">
          </div>
          -->
          <div class="comment-block">
            <div class="comment-header">
              <cite class="user"><a href="None" rel="nofollow">Petr Lapukhov</a></cite>
              <span class="datetime secondary-text">
                <a rel="nofollow" id="c1867737192590461015" href="#1867737192590461015">03 August 2010 17:41</a>
              </span>
            </div>
            <div class="comment-content">802.1aq has grown under strong influence of PBT from Nortel, so no wonder it look eeky, as the only benefit of PBT was ASIC reuse. For the routing loops, I still prefer separating control and data plane loops. Control plane loops may form during redistribution, for example. Control plane looping is typical when distance vector protocols are used. Even though the loops are realized at data plane, the primary source is control plane. Data plane loops are results of FIB inconsistency - i.e. Routing information is not looped in the control plane but routers are out of sync eg during reconvergence.</div>
          </div>
        </li>
      </div>
      <div>
        <li class="comment" id="701182390246493234">
          <!--
          <div class="avatar-image-container">
            <img src="https://resources.blogblog.com/img/blank.gif">
          </div>
          -->
          <div class="comment-block">
            <div class="comment-header">
              <cite class="user"><a href="None" rel="nofollow">Ivan Pepelnjak</a></cite>
              <span class="datetime secondary-text">
                <a rel="nofollow" id="c701182390246493234" href="#701182390246493234">03 August 2010 19:00</a>
              </span>
            </div>
            <div class="comment-content">All loops are caused by control plane (whether by async nature of LS routing protocols or route redistribution) and affect only the forwarding plane (unless we&#39;re talking about recursive routing bringing down a BGP session).</div>
          </div>
        </li>
      </div>
      <div>
        <li class="comment" id="535677833269484653">
          <!--
          <div class="avatar-image-container">
            <img src="https://resources.blogblog.com/img/blank.gif">
          </div>
          -->
          <div class="comment-block">
            <div class="comment-header">
              <cite class="user"><a href="None" rel="nofollow">Petr Lapukhov</a></cite>
              <span class="datetime secondary-text">
                <a rel="nofollow" id="c535677833269484653" href="#535677833269484653">04 August 2010 06:29</a>
              </span>
            </div>
            <div class="comment-content">Not all loops, here is a classic example: routing loops in BGP route reflector scenarios. Routes are distributed in loopless fashion (tree) but improper placement of clients/reflectors (not following the physical topology) may result in forwarding loop. <br /><br />Forwarding plane loops normally form in two cases: when you overlay routing over a physical topology, i.e. when routing protocol is not completely aware of the underlying link level mesh or when you implement route summarization, hiding specific routing information.<br /><br />It is worth making a definition: control plane loop is formed when the same routing prefix (used to create a forwardin entry) comes back to the domain of origin.  It is possible to detect these loops using control-plane mechanisms (path-tracing). Forwarding plane loops appear when routers do not have *consistent* view of the topology, e.g. due to summarization, reconvergence, hiding suboptimal paths etc, but not loops in routing information distribution. This distinction is important because control plane loops are detectable in advance, while forwarding loops are not.<br /><br />In case of the above BGP example, the forwarding plane loop is a result of full-mesh reduction and information minimization in route reflectors. Like said before, the forwarding plane loops are much harder to detect in advance, and therefore a data-plane mitiation mechanism is highly recommended.<br /><br />It is possible to completely avoid the forwarding plane loops by ensuring that forwarding information is always consistent among all forwarders. For example EIGRP achieves this by engaging every node in the topology in duffusing computation upon a change. BGP route reflectors could be made loop-free by using tunneling techniques, such as MPLS, which avoids BGP-based forwarding decision on core routers.<br /><br />As for bashing PBT for the lack of TTL label, it is curious to recall how Cell-Mode MPLS was operating (or even ATM separately). Lacking the support for the TTL field as well, both technologies were able to function &quot;perfectly&quot;, thanks to the fact that signaling protocols had full topology information and were able to detect control plane loops (e.g. by using path-vector TLV in LDP). Cell Mode MPLS was based on ordered LDP control mode, which allowed for proper (&quot;source-routed&quot;) forwarding path establishment upon a topology change. This prevented temporary IP forwarding tables inconsistencies from affecting cell-based pre-built paths. In the same manner, ATM was using pre-signaled source-routed SVCs, not to mention that PNNI was link-state at every level of hierarchy, thus allowing for full topology awareness.<br /><br />I haven&#39;t looked into 802.1aq specs in depth by any means, but if the forwarding paths are somehow programmed by edge nodes (e.g. by building distribution trees based on link-state information), then forwarding loops could be fully eliminated in the same manner as described above. But I can&#39;t make any other comments on that until some thorough reading.</div>
          </div>
        </li>
      </div>
      <div>
        <li class="comment" id="4043341985007466807">
          <!--
          <div class="avatar-image-container">
            <img src="https://resources.blogblog.com/img/blank.gif">
          </div>
          -->
          <div class="comment-block">
            <div class="comment-header">
              <cite class="user"><a href="None" rel="nofollow">Ivan Pepelnjak</a></cite>
              <span class="datetime secondary-text">
                <a rel="nofollow" id="c4043341985007466807" href="#4043341985007466807">04 August 2010 09:29</a>
              </span>
            </div>
            <div class="comment-content">As always, an excellent analysis. I&#39;ll just add a minor detail: it&#39;s quite impossible to have forwarding loops in source-initiated VC environment. There might be VC setup loop (which would be detected by the signaling protocol) but after the VC is set up, there&#39;s no way a loop could happen.</div>
          </div>
        </li>
      </div>
      <div>
        <li class="comment" id="2392685435849835075">
          <!--
          <div class="avatar-image-container">
            <img src="https://resources.blogblog.com/img/blank.gif">
          </div>
          -->
          <div class="comment-block">
            <div class="comment-header">
              <cite class="user"><a href="None" rel="nofollow">Petr Lapukhov</a></cite>
              <span class="datetime secondary-text">
                <a rel="nofollow" id="c2392685435849835075" href="#2392685435849835075">04 August 2010 20:56</a>
              </span>
            </div>
            <div class="comment-content">Thinking about it a few more times, 801.aq starts making a bit more sense now. The idea of preserving the same forwarding plane looks very attractive, based on the existing amount of inverstment in classic Ethernet switches. PBT failed to enter the SP market on the same reason - for SPs, everything was already packet-based and MPLS switched, so reinventing &quot;connection-oriented&quot; transport for Ethernet made little sense for SP core networks. At the same time, developing Metro Ethernet EVCs/OAM etc makes perfect sense for access networks.<br /><br />Of course, from a vendor standpoint a new hardware revenue stream (e.g. Nexus vs 6500) is more attractive compared to a simple control plane upgrade for the customers :) Using SPBV allows for completely preserving existing forwarding plane and hence the hardware; SPBM requires proper handing of stacked MAC addresses in the edge devices, which could be challenging for existing hardware (though I can&#39;t be sure here). If only IEEE wasn&#39;t that slow and rigid, they might have delivered something interesting for the data-center switches already.</div>
          </div>
        </li>
      </div>
      <div>
        <li class="comment" id="8285120661652196236">
          <!--
          <div class="avatar-image-container">
            <img src="https://resources.blogblog.com/img/blank.gif">
          </div>
          -->
          <div class="comment-block">
            <div class="comment-header">
              <cite class="user"><a href="None" rel="nofollow">Petr Lapukhov</a></cite>
              <span class="datetime secondary-text">
                <a rel="nofollow" id="c8285120661652196236" href="#8285120661652196236">05 August 2010 05:42</a>
              </span>
            </div>
            <div class="comment-content">The main critical observation I carried out so far from SPBV/SPBM is that load-splitting is pushed out to management plane: i.e. organized on per-customer VLAN (or more generally, service) basis. That is you cannot automatically use all 16 different distribution trees for the same VLAN (or service). This fact significantly diminishes value of 802.1aq multipathing for data centers, where automated flow-based load balancing is more appropriate. Management (offline) service to ECMT mapping better suits SP networks having &quot;rich&quot; set of customers/services at the edge. Unless the data center hosts large groups of isolated &quot;communities&quot; it cannot leverage much of 802.1aq multipathing.<br /><br />Interesting to notice how the PBT &quot;legacy&quot; intertwines the with the core ideas of SPB. After all, PBT was originally proposed as a solution that reduces the control plane and replaces it with rich management plane, found in classic transport networks. <br /><br />To finilize, I&#39;m not saying that flow-based load-balancing is not possible within the 802.1aq framework at all. For example, you may use control plane for distribution of a globally significant hash function used to map flows to the same SPTs. But this does not seem to be in focuse of IEEE group, at least at the moment.</div>
          </div>
        </li>
      </div>
      <div>
        <li class="comment" id="7335192210486958582">
          <!--
          <div class="avatar-image-container">
            <img src="https://resources.blogblog.com/img/blank.gif">
          </div>
          -->
          <div class="comment-block">
            <div class="comment-header">
              <cite class="user"><a href="None" rel="nofollow">nbragg@ciena.com</a></cite>
              <span class="datetime secondary-text">
                <a rel="nofollow" id="c7335192210486958582" href="#7335192210486958582">24 August 2010 17:55</a>
              </span>
            </div>
            <div class="comment-content">Nice to read an article which understands that SPB and TRILL are different.  The only unfortunate misconception is that no TTL means no loop prevention :<br />-   as if the organisation that is so paranoid about loops that it has hitherto used xSTP would not provide such mechanisms.  <br /><br />The mechanism of SPB exploits the richer knowledge available to nodes with link state, to block under topology change only trees where a node may have &quot;moved&quot; sufficiently wrt its parent and children&#39;s last known position that a loop is possible.  Such trees are unblocked when the node has regained a synchronised topology view with its neighbours.<br />-   otherwise, in the absence of danger of looping, trees continue to forward during reconvergence,<br />-   preserving this very attractive property of link state.<br /><br />Nigel Bragg</div>
          </div>
        </li>
      </div>
      <div>
        <li class="comment" id="7321402398279442547">
          <!--
          <div class="avatar-image-container">
            <img src="https://resources.blogblog.com/img/blank.gif">
          </div>
          -->
          <div class="comment-block">
            <div class="comment-header">
              <cite class="user"><a href="None" rel="nofollow">Ivan Pepelnjak</a></cite>
              <span class="datetime secondary-text">
                <a rel="nofollow" id="c7321402398279442547" href="#7321402398279442547">24 August 2010 18:11</a>
              </span>
            </div>
            <div class="comment-content">It&#39;s impossible for me to make any in-depth comment before reading the standard (which I could easily do in TRILL&#39;s case), so I&#39;ll keep it generic: routers running link state protocols receive updates and perform computations in totally asynchronous fashion. Of course it&#39;s possible to analyze what has changed from &quot;before&quot; to &quot;after&quot;, but the whole thing becomes &quot;somewhat&quot; complex.<br /><br />I understand the underlying reasons for the decision to use Q-in-Q or MAC-in-MAC (reuse existing chipset); only real-life experience will show whether the loop avoidance mechanisms work as expected (and I sincerely hope they do).</div>
          </div>
        </li>
      </div>
      <div>
        <li class="comment" id="1586304623744579292">
          <!--
          <div class="avatar-image-container">
            <img src="https://resources.blogblog.com/img/blank.gif">
          </div>
          -->
          <div class="comment-block">
            <div class="comment-header">
              <cite class="user"><a href="None" rel="nofollow">John Scaglietti</a></cite>
              <span class="datetime secondary-text">
                <a rel="nofollow" id="c1586304623744579292" href="#1586304623744579292">08 September 2010 14:59</a>
              </span>
            </div>
            <div class="comment-content">Hi<br /><br />You state:<br /><br />&quot;802.1aq has no relation to routing and none of the routing functionality. A loop generated by the control-plane protocol (for example, due to buggy implementation or distributed nature of IS-IS computations) can cause a network meltdown&quot;<br /><br />Well, in my opinion, both TRILL and SPBM use IS-IS to populate the forwarding tables and as such both benefit of the advantages of using a link state protocol. Inferring that one is a layer 3 protocol simply because the outer L2 encapsulation changes at every hop or because of the presence of a TTL field, is missing the point.<br />The fact that one only populates the FIB with the immediate next hop MAC (TRILL) while the other populates the FIB with the final destination node MAC (802.1aq) does not really change the substance of what is being achieved.<br />As for SPBM being loop prone that is not true. Using a TTL field is not the only way to implement loop suppression; it just happens to be the historical way used with IP. With SPBM the loop suppression is achieved by enforcing RPF (Reverse Path Forwarding) check on the source B-MAC of received frames (which of course is not possible with TRILL since the encapsulation changes at every hop). RPF is nothing new and is in fact used by IP routers when forwarding IP Multicast.<br />So even if the hypothetical transient loop did form, due to transient asymmetrical reconvergence of the control plane or whatever, TRILL might end up looping packets as many times as the inception value of the TTL field, whereas SPBM would suppress the loops immediately. So in theory SPBM is superior to TRILL on this point; in practice it&#39;s just two different approaches to solve the same problem.<br /><br />John Scaglietti</div>
          </div>
        </li>
      </div>
      <div>
        <li class="comment" id="901424794329935966">
          <!--
          <div class="avatar-image-container">
            <img src="https://resources.blogblog.com/img/blank.gif">
          </div>
          -->
          <div class="comment-block">
            <div class="comment-header">
              <cite class="user"><a href="None" rel="nofollow">Ivan Pepelnjak</a></cite>
              <span class="datetime secondary-text">
                <a rel="nofollow" id="c901424794329935966" href="#901424794329935966">11 September 2010 08:38</a>
              </span>
            </div>
            <div class="comment-content">Hi!<br /><br />Thanks for the comment. Since I wrote the post, several people have sent me details on 802.1aq loop avoidance methods and I have to admit it&#39;s an amazing work. It looks like the &quot;distributed nature of IS-IS computations&quot; is out of the picture; 802.1aq takes care of that.<br /><br />I have to study the standard a bit more to figure out the details of the RPF part, but if your forwarding tables are out-of-sync, the RPF check might not help you, as it would rely on incorrect information, resulting in either dropped traffic (that should have been forwarded) or forwarding loops.<br /><br />So, the question of software bugs remains. TRILL has a belt-and-braces approach (loops induced by the control plane are caught by the data plane), whereas 802.1aq relies solely on correct operation of the control plane.<br /><br />Would you agree with that?<br />Ivan</div>
          </div>
        </li>
      </div>
      <div>
        <li class="comment" id="6425525552475917573">
          <!--
          <div class="avatar-image-container">
            <img src="https://resources.blogblog.com/img/blank.gif">
          </div>
          -->
          <div class="comment-block">
            <div class="comment-header">
              <cite class="user"><a href="None" rel="nofollow">Peter</a></cite>
              <span class="datetime secondary-text">
                <a rel="nofollow" id="c6425525552475917573" href="#6425525552475917573">15 September 2010 08:19</a>
              </span>
            </div>
            <div class="comment-content">Just a couple of points.<br /><br />Concerning access to the IEEE documents. You will find that if you simply ask that access to the documents for the purposes of studying/writing about them is easy to obtain. So there is one more step than just grabbing the draft of the IETF server but its not a big deal. Certainly no $$ required. Drop one of us an email and we&#39;ll be happy to send interested parties a user id and password/link. Intelligent comments and review are more than welcome.<br /><br />The above statement about bugs in the control plane being able to cause loops. Actually you need very carefully crafted software to cause loops when RPFC is enabled. That is because you need to actually form TWO loops not just one. There has to be a forward loop AND a simultaneous and overlapping reverse loop. Unless you perfectly line up both loops in space and time data packets cannot loop in either direction.<br />Basically a packet looping based on the DA has to verify properly against the reverse loop in the SA.<br /><br />Peter Ashwood-Smith</div>
          </div>
        </li>
      </div>
      <div>
        <li class="comment" id="4981759370692042476">
          <!--
          <div class="avatar-image-container">
            <img src="https://resources.blogblog.com/img/blank.gif">
          </div>
          -->
          <div class="comment-block">
            <div class="comment-header">
              <cite class="user"><a href="None" rel="nofollow">Peter Ashwood-Smith</a></cite>
              <span class="datetime secondary-text">
                <a rel="nofollow" id="c4981759370692042476" href="#4981759370692042476">14 November 2010 00:22</a>
              </span>
            </div>
            <div class="comment-content">Just an update to my previous comment. Last month 802.1aq was put through Interoperability tests. The slides used to present this at both the IETF and IEEE are here:<br /><br />http://www.ieee802.org/1/files/public/docs2010/aq-ashwood-interop1-1110-v02.pdf<br /><br />Basically real switches were tested in a topology of 37 devices, 5 real, 32 emulated. Hardware datapaths, equal cost, and OA&amp;M were shown. <br /><br />We will be doing much more Interop testing in the new Year so stay tuned and we will keep the Wikipedia entry for IEEE 802.1aq up to date as we go.</div>
          </div>
        </li>
      </div>
      <div>
        <li class="comment" id="2346678868702245729">
          <!--
          <div class="avatar-image-container">
            <img src="https://resources.blogblog.com/img/blank.gif">
          </div>
          -->
          <div class="comment-block">
            <div class="comment-header">
              <cite class="user"><a href="None" rel="nofollow">Peter Phaal</a></cite>
              <span class="datetime secondary-text">
                <a rel="nofollow" id="c2346678868702245729" href="#2346678868702245729">10 December 2010 16:22</a>
              </span>
            </div>
            <div class="comment-content">There is a lot of interesting information on 802.1aq and TRILL on the NANOG50 web site:<br /><br />http://nanog.org/meetings/nanog50/agenda.php<br /><br />I thought the debate was particularly interesting:<br /><br />http://nanog.org/meetings/nanog50/presentations/Monday/great_debate_TRILL_vs_802.wmv</div>
          </div>
        </li>
      </div>
  </ol>

    </div>
  </div>
</div>
