{
  "comments": [
    {
      "comments": [
        {
          "date": "22 May 2019 11:35",
          "html": "Great comment! Have to add a discussion along these lines to the article. Here&#39;s the short version:<br /><br />In the end, you have to agree what your unique (node or interface) identifier is going to be - what database people would call &quot;primary key&quot;. It can be a UUID, an auto-increasing integer, or something that makes sense to you (in my case: hostname).<br /><br />Next problem: what happens when the primary key value changes and someone uses it in another table? Database people would call this one &quot;referential integrity&quot;. Relational databases solve the problem automatically (assuming you declared foreign key in the second table).<br /><br />You could also decide that you don&#39;t want to deal with referential integrity in which case the only chance of remaining consistent is to make sure primary keys never change.<br /><br />In the end, you have to decide where your balance between convenience and consistency is, and I would go for unique identifiers when working with databases fronted by business logic (API, GUI, CLI... or all of the above) and hostnames when working with text files.<br /><br />Obviously you&#39;d have to make sure your data model has referential integrity even when you work with text files - and that&#39;s why I&#39;m always telling engineers attending my Network Automation course that they should always validate input data.<br /><br />Hope this helps,<br />Ivan",
          "id": "3852885397744556836",
          "image": "https://lh3.googleusercontent.com/zFdxGE77vvD2w5xHy6jkVuElKv-U9_9qLkRYK8OnbDeJPtjSZ82UPq5w6hJ-SA=s35",
          "name": "Ivan Pepelnjak",
          "profile": "https://www.blogger.com/profile/13457151406311272386",
          "pub": "2019-05-22T11:35:17.176+02:00",
          "ref": "6819614118593962948",
          "type": "comment"
        }
      ],
      "date": "21 May 2019 21:17",
      "html": "Great article! Thank you for that. Looking for more to come. I find that the data model is the most crucial part in automation. Data deduplication and making the model flexible for future extension is hard.<br />Your examples still contain duplicate date e.g. neighbor name and interface. What if the hostname or interface change? You have the data in two places. You&#39;ve traded explicit complexity with implicit complexity.",
      "id": "6819614118593962948",
      "image": "https://lh3.googleusercontent.com/zFdxGE77vvD2w5xHy6jkVuElKv-U9_9qLkRYK8OnbDeJPtjSZ82UPq5w6hJ-SA=s35",
      "name": "Anonymous",
      "profile": "https://www.blogger.com/profile/17892204563666956100",
      "pub": "2019-05-21T21:17:40.578+02:00",
      "ref": "8456541039064900828",
      "type": "comment"
    },
    {
      "date": "22 May 2019 18:00",
      "html": "Perfect! Referential integrity is really the key here (in the truest sense of the word). Yes one has to made a trade off between convenience and consistency. Validating input data is of course very important but may not be sufficient to get referential integrity with text files. So only option left is as you stated a relational database with UUID and foreign key.",
      "id": "2986823113177592844",
      "image": "https://lh3.googleusercontent.com/zFdxGE77vvD2w5xHy6jkVuElKv-U9_9qLkRYK8OnbDeJPtjSZ82UPq5w6hJ-SA=s35",
      "name": "Anonymous",
      "profile": "https://www.blogger.com/profile/17892204563666956100",
      "pub": "2019-05-22T18:00:37.322+02:00",
      "ref": "8456541039064900828",
      "type": "comment"
    }
  ],
  "count": 3,
  "id": "8456541039064900828",
  "type": "post",
  "url": "2019/05/data-deduplication-in-network.html"
}