<div class="comments post" id="comments">
  <h4>17 comments:</h4>
  <div class="comments-content">
    <div class="comment-thread">
        <ol>
      <div>
        <li class="comment" id="1063510257202150754">
          <div class="comment-block">
            <div class="comment-header">
              <cite class="user"><a href="" rel="nofollow">Anonymous</a></cite>
              <span class="datetime secondary-text">
                <a rel="nofollow" id="c1063510257202150754" href="#1063510257202150754">12 April 2016 09:12</a>
              </span>
            </div>
            <div class="comment-content">Aside from the fact that a lot of applications would need to be re-written, I don&#39;t know why SCTP hasn&#39;t really taken off, except within the Telecoms sector.  </div>
              <div class="comment-replies">
                <div class="comment-thread inline-thread">
                  <span class="thread-count"><a>Replies</a></span>
                    <ol>
      <div>
        <li class="comment" id="6556481665690957761">
          <div class="comment-block">
            <div class="comment-header">
              <cite class="user"><a href="https://www.blogger.com/profile/07985346761439657130" rel="nofollow">Bela</a></cite>
              <span class="datetime secondary-text">
                <a rel="nofollow" id="c6556481665690957761" href="#6556481665690957761">12 April 2016 14:30</a>
              </span>
            </div>
            <div class="comment-content">Because SCTP requires a new API, so all applications have to be redesigned, recompliled, and redeployed. MPTCP is transparent to the legacy applications. However, sometimes this is a disadvantage. And SCTP still does not have a widely accepted concurrent multipath solutions. Normally, it could use only one active path.<br /></div>
          </div>
        </li>
      </div>
      <div>
        <li class="comment" id="3537870598873809642">
          <div class="comment-block">
            <div class="comment-header">
              <cite class="user"><a href="https://www.blogger.com/profile/13457151406311272386" rel="nofollow">Ivan Pepelnjak</a></cite>
              <span class="datetime secondary-text">
                <a rel="nofollow" id="c3537870598873809642" href="#3537870598873809642">12 April 2016 17:13</a>
              </span>
            </div>
            <div class="comment-content">To be more precise: with all networking libraries I&#39;ve seen so far you either have to specify which transport protocol you want to use (TCP or UDP) or can&#39;t specify it at all.<br /><br />Introducing SCTP thus causes application-level changes, not to mention the inability to get it through many firewall (at all - I&#39;m not even talking about new firewall rules).<br /><br />I wrote about the problems with SCTP a while ago (and earned quite a few &quot;you&#39;re an idiot&quot; accolades on Reddit or wherever it was reposted not so long ago):<br /><br />http://blog.ipspace.net/2009/08/what-went-wrong-sctp.html</div>
          </div>
        </li>
      </div>
      <div>
        <li class="comment" id="9092162034637215476">
          <div class="comment-block">
            <div class="comment-header">
              <cite class="user"><a href="https://www.blogger.com/profile/07985346761439657130" rel="nofollow">Bela</a></cite>
              <span class="datetime secondary-text">
                <a rel="nofollow" id="c9092162034637215476" href="#9092162034637215476">13 April 2016 14:38</a>
              </span>
            </div>
            <div class="comment-content">SCTP is the favorite protocol inside an IMS. It is used for all the sever-to-server interfaces for SIP and Diameter. It is not used for the clients, since it requires much more CPU than UDP, and for millions of devices you might not want to pay extra money for this required capacity extension. Usually, it is good enough for a single client to call again if something went wrong. However, in the IMS core you need quick seamless failover, and this is delivered by SCTP. The API changes for the Telco vendors are no problems, since they own the source code and anyhow alwayzs recompile their products.<br /></div>
          </div>
        </li>
      </div>
      <div>
        <li class="comment" id="7698978539161468851">
          <div class="comment-block">
            <div class="comment-header">
              <cite class="user"><a href="https://www.blogger.com/profile/07985346761439657130" rel="nofollow">Bela</a></cite>
              <span class="datetime secondary-text">
                <a rel="nofollow" id="c7698978539161468851" href="#7698978539161468851">13 April 2016 14:43</a>
              </span>
            </div>
            <div class="comment-content">If you need sub-20 or sub-10 ms failover in some safety critical domains, then you have to use active-active multiple copy multi-path transport. Both MPTCP and mSCTP could potentially deliver it, but sometimes you would do it at the application layer instead. On example is the linked session specification in EUROCAE ED-137. The mSCTP variant of SCTP is not widely implemented yet, so you might not be able to use it easily.<br /></div>
          </div>
        </li>
      </div>
      <div>
        <li class="comment" id="6518382079750436575">
          <div class="comment-block">
            <div class="comment-header">
              <cite class="user"><a href="https://www.blogger.com/profile/16010323799492079420" rel="nofollow">Olivier Bonaventure</a></cite>
              <span class="datetime secondary-text">
                <a rel="nofollow" id="c6518382079750436575" href="#6518382079750436575">13 April 2016 18:36</a>
              </span>
            </div>
            <div class="comment-content">To reach sub 20msec or sub-10 msec failover, you probably need to actively duplicate packets over disjoint paths. MPTCP could be extended to do that, but it is also possible to do this with layer 3 solutions like segment routing and regular TCP, see http://inl.info.ucl.ac.be/publications/traffic-duplication-through-segmentable-disjoint-paths</div>
          </div>
        </li>
      </div>
  </ol>

                </div>
              </div>
          </div>
        </li>
      </div>
      <div>
        <li class="comment" id="652983164919254239">
          <div class="comment-block">
            <div class="comment-header">
              <cite class="user"><a href="https://www.blogger.com/profile/07985346761439657130" rel="nofollow">Bela</a></cite>
              <span class="datetime secondary-text">
                <a rel="nofollow" id="c652983164919254239" href="#652983164919254239">12 April 2016 14:33</a>
              </span>
            </div>
            <div class="comment-content">IPv6 started well by becoming v2 of IPX. And then came some fashion people and destroyed it... :-(<br />Now networking is totally a fashion industry, always taking the old clothes and re-purposing as something totally new... :-)<br />Look at Named Data Networking (NDN) if you want to be fashionable! :-)<br /></div>
          </div>
        </li>
      </div>
      <div>
        <li class="comment" id="7280711625723940688">
          <div class="comment-block">
            <div class="comment-header">
              <cite class="user"><a href="" rel="nofollow">Anonymous</a></cite>
              <span class="datetime secondary-text">
                <a rel="nofollow" id="c7280711625723940688" href="#7280711625723940688">13 April 2016 02:40</a>
              </span>
            </div>
            <div class="comment-content">&quot;New age solutions use scale-out application architecture&quot; :<br /><br />DNS has had this architecture since its inception in 1985.</div>
          </div>
        </li>
      </div>
      <div>
        <li class="comment" id="232577840087691677">
          <div class="comment-block">
            <div class="comment-header">
              <cite class="user"><a href="https://www.blogger.com/profile/09771677856264877238" rel="nofollow">Jeff Behrns</a></cite>
              <span class="datetime secondary-text">
                <a rel="nofollow" id="c232577840087691677" href="#232577840087691677">13 April 2016 03:13</a>
              </span>
            </div>
            <div class="comment-content">Please don&#39;t ever stop doing what you do Mr. Ivan P.  At times you may feel like your efforts are futile.  But, some people are definitely listening and taking notes.</div>
          </div>
        </li>
      </div>
      <div>
        <li class="comment" id="6784893223648512804">
          <div class="comment-block">
            <div class="comment-header">
              <cite class="user"><a href="https://www.blogger.com/profile/08333059712411851393" rel="nofollow">David Barroso</a></cite>
              <span class="datetime secondary-text">
                <a rel="nofollow" id="c6784893223648512804" href="#6784893223648512804">13 April 2016 10:05</a>
              </span>
            </div>
            <div class="comment-content">MPTCP contemplates multihomed services. However, due to NAT they decided to focus on implementing MPTCP on the client side first. It will probably not be feasible to implement it on the server side on the IPv4 side but it might be doable on IPv6 if firewalls start to understand the new MPTCP headers and allow new subflows initiated by the server on an existing flow.<br /><br />However, I would rather solve the problem by running BGP on the host. Oh, wait. I am already doing that and it just worksâ„¢ ;)</div>
              <div class="comment-replies">
                <div class="comment-thread inline-thread">
                  <span class="thread-count"><a>Replies</a></span>
                    <ol>
      <div>
        <li class="comment" id="6023408330458081408">
          <div class="comment-block">
            <div class="comment-header">
              <cite class="user"><a href="https://www.blogger.com/profile/08333059712411851393" rel="nofollow">David Barroso</a></cite>
              <span class="datetime secondary-text">
                <a rel="nofollow" id="c6023408330458081408" href="#6023408330458081408">13 April 2016 11:32</a>
              </span>
            </div>
            <div class="comment-content">In any case, MPTCP solves two different problems with some overlapping.</div>
          </div>
        </li>
      </div>
      <div>
        <li class="comment" id="6809629231271856192">
          <div class="comment-block">
            <div class="comment-header">
              <cite class="user"><a href="https://www.blogger.com/profile/16010323799492079420" rel="nofollow">Olivier Bonaventure</a></cite>
              <span class="datetime secondary-text">
                <a rel="nofollow" id="c6809629231271856192" href="#6809629231271856192">13 April 2016 18:39</a>
              </span>
            </div>
            <div class="comment-content">Apple uses Multipath TCP servers to support all the iPhones and iPads that use Siri. This is a significant deployment of Multipath TCP on the server side.</div>
          </div>
        </li>
      </div>
      <div>
        <li class="comment" id="7666098549671093580">
          <div class="comment-block">
            <div class="comment-header">
              <cite class="user"><a href="https://www.blogger.com/profile/16010323799492079420" rel="nofollow">Olivier Bonaventure</a></cite>
              <span class="datetime secondary-text">
                <a rel="nofollow" id="c7666098549671093580" href="#7666098549671093580">13 April 2016 18:45</a>
              </span>
            </div>
            <div class="comment-content">I&#39;m not convinced that combining loopback addresses on the servers with with unnumbered physical interfaces is the best approach because it relies too much on the network. With this approach, the network will always forward the packets along the shortest path to the loopback address of the host. If the host is connected to two different switches for redundancy, then it means that only one link will be used. If the link fails, you&#39;ll have to wait for the IGP convergence (or worse iBGP if you put BGP on the hosts) to recover from the failure.<br /><br />A different but more powerful design is to use a loopback address on the host and regular IP addresses on the physical interfaces with Multipath TCP. The loopback address is used as a rendez-vous point to establish the initial subflow but Multipath TCP advertises the addresses of the physical interfaces and traffic automatically flows along them. If there is not enough bandwidth on one interface, Multipath TCP will use the second. If one link fails, Multipath TCP will recover within a rtt. I&#39;ve heard some people using this approach with CEPH servers and they seemed to be pretty happy with it. </div>
          </div>
        </li>
      </div>
      <div>
        <li class="comment" id="1648881503329832344">
          <div class="comment-block">
            <div class="comment-header">
              <cite class="user"><a href="https://www.blogger.com/profile/08333059712411851393" rel="nofollow">David Barroso</a></cite>
              <span class="datetime secondary-text">
                <a rel="nofollow" id="c1648881503329832344" href="#1648881503329832344">13 April 2016 18:57</a>
              </span>
            </div>
            <div class="comment-content">Sure, but you forget that the servers can&#39;t initiate subflows. Only the client can and that means that even if the server is multi-homed it can&#39;t take advantage of the multiple IPs without some sort of dynamic routing.<br /><br />The only way a server could initiate sub flows would be if middle boxes sitting on ISPs doing NAT and security would understand MPTCP headers so they could match existing flow entries with new subflows.</div>
          </div>
        </li>
      </div>
      <div>
        <li class="comment" id="8995477728207898801">
          <div class="comment-block">
            <div class="comment-header">
              <cite class="user"><a href="https://www.blogger.com/profile/16010323799492079420" rel="nofollow">Olivier Bonaventure</a></cite>
              <span class="datetime secondary-text">
                <a rel="nofollow" id="c8995477728207898801" href="#8995477728207898801">15 April 2016 11:56</a>
              </span>
            </div>
            <div class="comment-content">The protocol spec allows both clients and servers to create subflows. The default path managers in the Linux kernel implementation assume that only clients will create subflows, but this can be changed by writing another path manager. See http://inl.info.ucl.ac.be/publications/smapp-towards-smart-multipath-tcp-enabled-applications for a user space path manager that allows a daemon to manage the subflows used by MPTCP</div>
          </div>
        </li>
      </div>
  </ol>

                </div>
              </div>
          </div>
        </li>
      </div>
      <div>
        <li class="comment" id="8128543446266724457">
          <div class="comment-block">
            <div class="comment-header">
              <cite class="user"><a href="https://www.blogger.com/profile/16364104069783107658" rel="nofollow">michaelc0n</a></cite>
              <span class="datetime secondary-text">
                <a rel="nofollow" id="c8128543446266724457" href="#8128543446266724457">03 May 2016 01:01</a>
              </span>
            </div>
            <div class="comment-content">How about BGP in-host and peering to ToR to solve this...kind of like an ESG (vmware)</div>
              <div class="comment-replies">
                <div class="comment-thread inline-thread">
                  <span class="thread-count"><a>Replies</a></span>
                    <ol>
      <div>
        <li class="comment" id="420763776863029773">
          <div class="comment-block">
            <div class="comment-header">
              <cite class="user"><a href="https://www.blogger.com/profile/13457151406311272386" rel="nofollow">Ivan Pepelnjak</a></cite>
              <span class="datetime secondary-text">
                <a rel="nofollow" id="c420763776863029773" href="#420763776863029773">03 May 2016 12:29</a>
              </span>
            </div>
            <div class="comment-content">How about this sentence in one of the last paragraphs: &quot;Trying to solve the problem in the network layer ... you could use BGP&quot; ;)</div>
          </div>
        </li>
      </div>
  </ol>

                </div>
              </div>
          </div>
        </li>
      </div>
  </ol>

    </div>
  </div>
</div>
