{
  "comments": [
    {
      "comments": [
        {
          "date": "13 October 2018 19:06",
          "html": "While I (as is most often the case) totally agree with you, you&#39;re talking about reasonable world. Unfortunately I&#39;ve seen way too many cases where people kept heaping abstraction layers on top of abstraction layers out of sheer laziness or worse. <br /><br />I would say this is the canonical example: https://qz.com/646467/how-one-programmer-broke-the-internet-by-deleting-a-tiny-piece-of-code/<br /><br />Also, I&#39;m guessing we&#39;re both old enough to remember Pascal (and other compiled languages), and I don&#39;t think our speed of development (of reasonable-quality code) was ever significantly impacted by the compilation time.",
          "id": "3011904952368341819",
          "image": "https://lh3.googleusercontent.com/zFdxGE77vvD2w5xHy6jkVuElKv-U9_9qLkRYK8OnbDeJPtjSZ82UPq5w6hJ-SA=s35",
          "name": "Ivan Pepelnjak",
          "profile": "https://www.blogger.com/profile/13457151406311272386",
          "pub": "2018-10-13T19:06:02.793+02:00",
          "ref": "7811604663277627971",
          "type": "comment"
        },
        {
          "date": "13 October 2018 23:54",
          "html": "As to compile, try 40-50 MLOC lines (as in millions ;-) of code that is nothing particular at all for a complex system these days ... Only an extended handful of shops have people smart/hard working/experienced enough to keep compile times/abstraction/sanity on something like this in parameters ... <br /><br />But then yes, as anything, abstraction and layering can be a fetish ;-) <br /><br />And ultimately, I wouldn&#39;t mention JavaScript and reasonable in the same sentence or even book ... JavaScript is like PHP, it&#39;s a statement of belief largely rather than a logical calculus a normal programming language is. ",
          "id": "1915903519367552475",
          "image": "https://lh3.googleusercontent.com/zFdxGE77vvD2w5xHy6jkVuElKv-U9_9qLkRYK8OnbDeJPtjSZ82UPq5w6hJ-SA=s35",
          "name": "Tony P",
          "profile": "https://www.blogger.com/profile/07732539097585801151",
          "pub": "2018-10-13T23:54:25.314+02:00",
          "ref": "7811604663277627971",
          "type": "comment"
        },
        {
          "date": "14 October 2018 08:33",
          "html": "Looks like we&#39;ll have to continue this discussion over (a large set of) beer(s). You&#39;re talking about giant monolithic systems, whereas the article mostly focuses on the crap deployed as web apps... and yes, most of its rant is targeting the likes of JavaScript and PHP.",
          "id": "1850395889454296575",
          "image": "https://lh3.googleusercontent.com/zFdxGE77vvD2w5xHy6jkVuElKv-U9_9qLkRYK8OnbDeJPtjSZ82UPq5w6hJ-SA=s35",
          "name": "Ivan Pepelnjak",
          "profile": "https://www.blogger.com/profile/13457151406311272386",
          "pub": "2018-10-14T08:33:19.739+02:00",
          "ref": "7811604663277627971",
          "type": "comment"
        },
        {
          "date": "15 October 2018 16:59",
          "html": "I&#39;m not talking monolitic, I&#39;m talking reasonable _systems_ whether you put them together with some freebies and automation or buy a vertically integrated product or mix things. Those things have huge volumes no matter what you do ... But that&#39;s beside the point. <br /><br />If we talk PHP and JavaScript it&#39;s not worth the time, it&#39;s not a very interesting discussion IMO and it seems an odd discussion for ipSpace anyway ... ",
          "id": "1387198339109878566",
          "image": "https://lh3.googleusercontent.com/zFdxGE77vvD2w5xHy6jkVuElKv-U9_9qLkRYK8OnbDeJPtjSZ82UPq5w6hJ-SA=s35",
          "name": "Tony P",
          "profile": "https://www.blogger.com/profile/07732539097585801151",
          "pub": "2018-10-15T16:59:10.040+02:00",
          "ref": "7811604663277627971",
          "type": "comment"
        },
        {
          "date": "15 October 2018 17:03",
          "html": "&quot;If we talk PHP and JavaScript it&#39;s not worth the time&quot; &lt;&lt; and yet a lot of so-called SDN and automation stuff out there is written in Python which might or might not be better than PHP based on your religious beliefs ;)",
          "id": "4690280684681720461",
          "image": "https://lh3.googleusercontent.com/zFdxGE77vvD2w5xHy6jkVuElKv-U9_9qLkRYK8OnbDeJPtjSZ82UPq5w6hJ-SA=s35",
          "name": "Ivan Pepelnjak",
          "profile": "https://www.blogger.com/profile/13457151406311272386",
          "pub": "2018-10-15T17:03:41.287+02:00",
          "ref": "7811604663277627971",
          "type": "comment"
        }
      ],
      "date": "13 October 2018 18:58",
      "html": "There are many more aspects to the whole thing than the rather naive (IME) post. First, optimizing software makes it inherently less portable, less maintainable and ultimately more &quot;fragile&quot; normally. If the problem is well understood, doesn&#39;t change quickly and justifies lots of resources to be solved @ high performance, then it&#39;s worth doing, most problems in software are not like this. Ultimately, if the problem is _really_ well understood, performance _really_ matters and there is _real_ money on the table, silicon is built which is a very rigorous process. But then lots of people turn around and are disappointed that a free lunch of high-performance and 2 weeks release cycles is not attainable. <br /><br />When requirements are loose and are changing fast (which is the enchantment of the day  as in &quot;software can do anything and be changed on a whim&quot;) and there isn&#39;t enough money in it on top (enters open-source) and on top of the top it has to be kept maintainable (staff turnover, portability, stable APIs to plug into other stuff) then layering and abstraction naturally takes over (which is really our only way to deal with massive amount of complexity in somewhat predictable fashion by containing the blast radius of the entropy being pumped into the system). Layering means indirections and that means performance loss on today&#39;s computer architecture in prevailing languages @ least. There is work being done in modern CS emphasizing &quot;zero-cost-abstraction&quot; and natural parallelization (which is a rewarding but difficult path to performance) but this ends up in lambda-calculus corner pretty much which @ this point in time few programmers understand IME since it&#39;s more math than the usual &quot;let&#39;s put bunch loops and ifs together&quot; and slides quickly into distributed systems theory that is easy to get 99% correct and then the last 1% is impossible to debug if one doesn&#39;t have enough understanding of the basics of it ...  <br /><br />well, my usual 2c &quot;no free lunch&quot; flavor ... ",
      "id": "7811604663277627971",
      "image": "https://lh3.googleusercontent.com/zFdxGE77vvD2w5xHy6jkVuElKv-U9_9qLkRYK8OnbDeJPtjSZ82UPq5w6hJ-SA=s35",
      "name": "Tony P",
      "profile": "https://www.blogger.com/profile/07732539097585801151",
      "pub": "2018-10-13T18:58:09.903+02:00",
      "ref": "4854969660432753668",
      "type": "comment"
    },
    {
      "comments": [
        {
          "date": "16 October 2018 20:13",
          "html": "60% ascetics !<br /><br />Did you mean aesthetics/esthetics? (a branch of philosophy dealing with beauty and the beautiful)<br /><br />Or did you really mean asceticism? (a lifestyle characterized by abstinence from sensual pleasures, often for the purpose of pursuing spiritual goals)",
          "id": "2821619813391135934",
          "image": "https://resources.blogblog.com/img/blank.gif",
          "name": "Anonymous",
          "profile": null,
          "pub": "2018-10-16T20:13:57.158+02:00",
          "ref": "8852297864563355298",
          "type": "comment"
        }
      ],
      "date": "15 October 2018 01:21",
      "html": "Honestly, it is all of our faults.  We like and/or created the users who like easy and pretty application experiences.  Modern programming and software design is 5% problem solving, 60% ascetics, 25% making it as idiot &quot;resistant&quot; as possible, then 10% more problem solving due to adding all the unnecessarily ascetic touches and idiot resistant bloat.  Yes, idiot resistant; there is no such thing as idiot proof.  We are caught in a repeating cycle of dumbing things down and prettying them up, just so the current user base can utilize things without thought. This breeds the next generation of less resourceful users.  Honestly, we all love the benefits of the new &quot;easy button&quot; world.  Just think of the early morning call with your parents or other family members trying to explain how to do something tech related....  That being said, the art of simplicity is being lost.  We could all use a little RFC1925 rule 12 like methodology in our designs.    ",
      "id": "8852297864563355298",
      "image": "https://lh3.googleusercontent.com/zFdxGE77vvD2w5xHy6jkVuElKv-U9_9qLkRYK8OnbDeJPtjSZ82UPq5w6hJ-SA=s35",
      "name": "Unknown",
      "profile": "https://www.blogger.com/profile/17387058695201425015",
      "pub": "2018-10-15T01:21:01.692+02:00",
      "ref": "4854969660432753668",
      "type": "comment"
    },
    {
      "date": "20 October 2018 15:24",
      "html": "aesthetics, sorry lex-dysia got me again<br />",
      "id": "1871766131225781878",
      "image": "https://lh3.googleusercontent.com/zFdxGE77vvD2w5xHy6jkVuElKv-U9_9qLkRYK8OnbDeJPtjSZ82UPq5w6hJ-SA=s35",
      "name": "Unknown",
      "profile": "https://www.blogger.com/profile/17387058695201425015",
      "pub": "2018-10-20T15:24:28.508+02:00",
      "ref": "4854969660432753668",
      "type": "comment"
    }
  ],
  "count": 9,
  "id": "4854969660432753668",
  "type": "post",
  "url": "2018/10/worth-reading-software-disenchantment.html"
}