<div class="comments post" id="comments">
  <h4>6 comments:</h4>
  <div class="comments-content">
    <div class="comment-thread">
        <ol>
      <div>
        <li class="comment" id="7638025245099734873">
          <div class="comment-block">
            <div class="comment-header">
              <cite class="user"><a href="" rel="nofollow">Anonymous</a></cite>
              <span class="datetime secondary-text">
                <a rel="nofollow" id="c7638025245099734873" href="#7638025245099734873">05 April 2018 11:36</a>
              </span>
            </div>
            <div class="comment-content">I just want to call a RPC on the remote device (with probably protocol buffers) and the device knows what to do (intent based). I don&#39;t want to guess the URL as I was told at a course from a big vendor (basically do a show run with REST and find the URL based on JSON structure because of lack of documentation). Maybe the vendors get there before my pension.</div>
          </div>
        </li>
      </div>
      <div>
        <li class="comment" id="5743353635663619092">
          <div class="comment-block">
            <div class="comment-header">
              <cite class="user"><a href="https://www.blogger.com/profile/14125453173202486491" rel="nofollow">Edward</a></cite>
              <span class="datetime secondary-text">
                <a rel="nofollow" id="c5743353635663619092" href="#5743353635663619092">05 April 2018 15:48</a>
              </span>
            </div>
            <div class="comment-content">The reason people are so REST happy is because there are a LOT of tools that make using REST calls fairly simple.  As Anonymous mentioned - looking for a URL and then having to have all the headers exactly right can be tedious, at best.  <br />I think RPCs are much cleaner (and most vendor implementations of REST are just wrappers around the RPC anyway) and make more sense, especially to a network engineer who is trying to automate something.  <br />REST has some things going for it, such as language freedom, the tools that I mentioned before and there are a plethora of tutorials on using REST on the web that can give someone enough information on &quot;how&quot; to use REST so they can at least attempt it with a device without ever knowing exactly what the vendor has implemented.  <br />However, REST has overhead, IMO is only a couple steps ahead of SOAP (which sucks) and as a network engineer, if I have to read my own or someone else&#39;s code, looking at RPCs is much cleaner than all the crap you have to use to create a REST call.   </div>
          </div>
        </li>
      </div>
      <div>
        <li class="comment" id="961741908461397322">
          <div class="comment-block">
            <div class="comment-header">
              <cite class="user"><a href="https://www.blogger.com/profile/12988992137744664604" rel="nofollow">russell</a></cite>
              <span class="datetime secondary-text">
                <a rel="nofollow" id="c961741908461397322" href="#961741908461397322">05 April 2018 21:31</a>
              </span>
            </div>
            <div class="comment-content">Really its more about having some interface other than screen scraping a CLI to deliver &quot;intent&quot; to the device. As long as it&#39;s a consistent interface across devices on my network I don&#39;t care if it&#39;s REST or RPC based. I think the reason people push a lot for REST is because it&#39;s pretty common across devices and systems. That said I like the Arista approach here since it allows a networking engineer to carry their existing skills right into network programmability. <br /><br />I&#39;d say given a lack of anything else there should at least be a REST API to interface with. </div>
              <div class="comment-replies">
                <div class="comment-thread inline-thread">
                  <span class="thread-count"><a>Replies</a></span>
                    <ol>
      <div>
        <li class="comment" id="4317643647569825433">
          <div class="comment-block">
            <div class="comment-header">
              <cite class="user"><a href="http://www.idk.com" rel="nofollow">Dennis</a></cite>
              <span class="datetime secondary-text">
                <a rel="nofollow" id="c4317643647569825433" href="#4317643647569825433">06 April 2018 06:49</a>
              </span>
            </div>
            <div class="comment-content">I agree, it’s just about having a programmable interface.<br />Also agree that in my experience it is enough to have the capability to replace the whole running configuration without any service interruption like juniper offers, at least if you are going to do all of your configuration changes through a custom built application. You can just create a full configuration each time you make a change and replace it instead of figuring out different api calls based on the change you made and this also makes it easy to monitor for difference between the real running configuration and the configuration from your database. In addition you only need to use other api calls for some show commands to monitor state that cannot be seen in the configuration.<br />I also made the experience that automation using screen scraping is possible (HP Provision) but takes much longer and is prone to errors. You also have to solve stupid problems like timing errors during login and command execution, etc. so I would only recommend that if you have a lot of those devices which are too expensive to replace and are not planning to implement too many complex features in your automation solution (we only use it for l2 switches for example).<br />So I don’t think REST is needed but you should look for devices which have a good interface for automation if you have any possible plans in that direction. </div>
          </div>
        </li>
      </div>
  </ol>

                </div>
              </div>
          </div>
        </li>
      </div>
      <div>
        <li class="comment" id="6067818548519457857">
          <div class="comment-block">
            <div class="comment-header">
              <cite class="user"><a href="http://l33.fr" rel="nofollow">Blake</a></cite>
              <span class="datetime secondary-text">
                <a rel="nofollow" id="c6067818548519457857" href="#6067818548519457857">06 April 2018 14:33</a>
              </span>
            </div>
            <div class="comment-content">I&#39;ll take a native Python API over REST any day of the week<br /><br />&amp; protocol buffers are a bonus<br /><br />but to answer your question, if I were given the choice between REST API &amp; CLI/config file, well, CLI/conf wins hands down</div>
          </div>
        </li>
      </div>
      <div>
        <li class="comment" id="431413835051461216">
          <div class="comment-block">
            <div class="comment-header">
              <cite class="user"><a href="https://www.blogger.com/profile/06314916176190119200" rel="nofollow">A Network Artist</a></cite>
              <span class="datetime secondary-text">
                <a rel="nofollow" id="c431413835051461216" href="#431413835051461216">08 April 2018 07:17</a>
              </span>
            </div>
            <div class="comment-content">Hi Ivan,<br /><br />Thanks for the wonderful post. <br /><br />Since I haven’t been deep into Automation and API yet myself but have spent some time digging into those areas in general for my understanding, so wanted to check if my understanding is correct or I am missing something while I am waiting for a REST API webinar of yours. ��<br /><br />To me REST is just another fancy interface and not very different from the way currently CLI works.<br /><br />We essentially make REST calls which needs to follow :<br /><br />- URL<br />- Authentication<br />- Some REST command &quot;essentially again syntax defined by vendor in documentation &quot; - Well sounds like old days &quot; Alias &quot; to me ��<br />- Obviously it doesn&#39;t necessarily define format such as JSON, XML (which are my choices but not sure if those are consistent across vendors and platforms )<br /><br />In order for multiple devices to work as a system, we are looking for essentially REST as way to provide standard interface. But you still have pretty much same set of challenges that &quot; CLI &quot; poses.<br /><br />- REST commands are platform and vendor specific<br />- You still need to get the order of operation or sequence right to ensure you &quot; Intent &quot; can be consumed by end device<br /><br />And if I am not wrong until this point :)<br /><br />-  We can similarly consider &quot; CLI &quot; as universal interface - SSH is enough secure too (Atomic function might be a requirement but Juniper has fixed it right from beginning while status codes are easy to define as long as vendor would want to) <br />- The sequence still needs to be followed<br />- We can talk to pretty much any device (pretty old ones too) - Most Orchestrator vendors realized it at some point including guys from Ansible ��<br />- Yes we need to follow every vendors &quot; CLI &quot; structure but I guess that is same problem with REST too<br /><br />Now question is how to do it better ?<br /><br />I know Open Config, YANG (Little I know about ) are trying to fix the problems in terms of how we push/pull the configurations/stats. Though I am not sure if it’s easy to standardize this across Vendors. But this approach still doesn’t solve the problem I described above for most part.<br /><br />Also I quickly wanted to know your take on troubleshooting a device with Just REST API interface. Shall the Engineer memorize now REST commands instead of CLI commands for given platform as we know most GUI based systems are far less flexible today in terms of customization support or else it comes at price. <br /><br />And did I suggest that the data returned by REST call such as GET is not standardized either and many vendors just send and receive old CLI commands over REST and claim they offer REST interface for interaction.<br /><br />Thanks!<br />Evil CCIE<br /></div>
          </div>
        </li>
      </div>
  </ol>

    </div>
  </div>
</div>
