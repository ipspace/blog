{
   "comments": [
      {
         "date": "14 May 2025 03:55",
         "html": "<p>I&#39;ve been enjoying this series so much. This topic is coming up so much lately. I hope we can get some sensible path forward. </p>\n",
         "id": "2633",
         "name": " Mark Prosser",
         "pub": "2025-05-14T15:55:49",
         "type": "comment"
      },
      {
         "comments": [
            {
               "date": "16 May 2025 11:19",
               "html": "<p>Interesting post as always from Mr. Ivan. <br />\nAnother twist on this subject. </p>\n\n<p>For years you hear about how network professionals must become programmers(for hyped AI to replace anyway) and learn programming languages for their jobs so they can build automation tools etc.\nYet it seems the industry misses the fact(or they hid /re-cast it on purpose to sell some new &ldquo;product&rdquo;) that the CLI is and has been the network engineers programming language and indirect API since the start.  The network CLI has programming constructs like verbs and literals, variables(ip address under an interface etc) and functions/methods like BGP or OSPF process and each interface is a &ldquo;function&rdquo; you program the function(assign the IP) enable it and it runs in its loop as UP/UP until another condition. Access lists, PBR, static routes(go to) alias statements, event manager applets, etc are all programmatic language like with structures in the CLI that you carefully have to plan and test just like any other coding project. There are probably more accurate analogies to what I am expressing her but you get the &lsquo;gist&rsquo; of it. </p>\n\n<p>So this post regarding the CLI is an API and screen scraping is probably still easier is interesting. </p>\n\n<p>So now the vendors build these APIs that use what? CLI &ndash; NXOS for example where  you have python accessible API using what, CLI commands.</p>\n\n<p>or using the NX API sandbox and what method do you start out with is the  NXAPI-CLI   nice rhyme to it\n    &quot;jsonrpc&quot;: &quot;2.0&quot;,\n    &quot;method&quot;: &quot;cli&quot;,\n    &quot;params&quot;: &#123;\n      &quot;cmd&quot;: &quot;show interface&quot;,\n      &quot;version&quot;: 1</p>\n\n<p>Or under Python\nImport cisco\ncisco.cli(&#39;show hostname&#39;)\ncisco.cli(&quot;config t&quot;)\ncisco.cli(&quot;interface vlan2&quot;)\ncisco.cli(&quot;ip address&quot;, ipadd)\ncisco.cli(&quot;end&quot;)\ncisco.cli(&quot;show interface vlan2&quot;)</p>\n\n<p>&hellip; but hey  - sarcasm - &ldquo; it is the dreadful cli&rdquo; and those &ldquo;cli jockeys&rdquo; vendors have been selling to get us off of for decades.&hellip;&hellip;.</p>\n\n<p>hmm so why use the CLI &ldquo;constructs&rdquo; in python, ansible and xCONF and rest API  access methods accessing the same CLI directly  via the OS&rsquo;s  key/value XML, JSON and YAML data serialization and YANG constructs of cli structure command verbs.</p>\n\n<p>Why not rid the industry of the sarcasm - &ldquo;dreadful cli&rdquo;- and build closed network OS  with only a GUI and API that can only be controlled by the GUI operator(human) and automated or controlled/orchestrated by an API with commands that are only closed coded rest, python etc and sent to the device. There is no  line by line interface for the user to directly enter commands immediate feedback via a keyboard. </p>\n\n<p>But it seems the great and powerful CLI language is the language for most of the other tools(and screen scrapers) to utilize. The only issue industrywide was there was no standard CLI due to multivendor and patent considerations vs some standards present  for C and python etc.</p>\n\n<p>Will the open user presented CLI survive or will vendors make their solutions purely closed box(no serial console), only interfaced via a GUI or through an API(eventually AI agent) that uses programming verbs(not human typed commands) you cannot execute yourself, unless of course someone strings the closed API&rsquo;s verbs together in the form of (hmm alias commands) for you and presents them in the GUI app so what you type in the GUI app&rsquo;s &ldquo;command line&rdquo; prompt is then sent via API to the devices and guess what?,,, we just re-invented an off box cli and back to the beginning &#x1F609; \nOh brother ahh just leave the CLI alone and keep it. </p>\n",
               "id": "2635",
               "name": "Jsicuran",
               "pub": "2025-05-16T23:19:52",
               "ref": "2634",
               "type": "comment"
            }
         ],
         "date": "16 May 2025 07:01",
         "html": "<p>At least projects like ntc-templates and ttp-templates make regex a little more tolerable to work with on network devices.</p>\n",
         "id": "2634",
         "name": " Charles Monson",
         "pub": "2025-05-16T19:01:35",
         "type": "comment"
      },
      {
         "comments": [
            {
               "date": "17 May 2025 10:27",
               "html": "<p>Thanks a million for the feedback. One would hope that regex parsers coming from a vendor would be better tested and I would definitely just match up/down states in your example, not the end-of-line. OTOH I have to admit I never saw that VRF exception you mentioned in your blog post in my life.</p>\n",
               "id": "2637",
               "name": " Ivan Pepelnjak",
               "pub": "2025-05-17T10:27:54",
               "ref": "2636",
               "type": "comment"
            }
         ],
         "date": "17 May 2025 08:06",
         "html": "<p>pyATS/Genie is a good example on why you shouldn&#39;t parse CLI with regexes, notably &quot;liberal&quot; ones. You are likely to extract incorrect information. I have written about that a few years back and I believe this is still correct today: https://vincent.bernat.ch/en/blog/2021-pyats-genie-parser.</p>\n",
         "id": "2636",
         "name": "Vincent Bernat",
         "pub": "2025-05-17T08:06:52",
         "type": "comment"
      }
   ],
   "count": 3,
   "type": "post",
   "url": "2025/05/response-cli-api.html"
}
