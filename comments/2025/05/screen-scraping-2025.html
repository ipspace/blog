<div class="comments post" id="comments">
  <h4>3 comments:</h4>
  <div class="comments-content">
    <div class="comment-thread">
        <ol>
      <div>
        <li class="comment" id="2627">
          <div class="comment-block">
            <div class="comment-header">
              <cite class="user"><a href="" rel="nofollow"> sngx13</a></cite>
              <span class="datetime secondary-text">
                <a rel="nofollow" id="c2627" href="#2627">07 May 2025 04:12</a>
              </span>
            </div>
            <div class="comment-content"><p>That&#39;s why I absolutely love EOS, no need to use text_fsm or ntc_templates, just run the command, get output and json.load it :-)</p>
</div>
          </div>
        </li>
      </div>
      <div>
        <li class="comment" id="2630">
          <div class="comment-block">
            <div class="comment-header">
              <cite class="user"><a href="" rel="nofollow"> Bob</a></cite>
              <span class="datetime secondary-text">
                <a rel="nofollow" id="c2630" href="#2630">12 May 2025 05:46</a>
              </span>
            </div>
            <div class="comment-content"><p>Hi Ivan. Thank you for another great article.</p>

<p>I mostly agree with your main point: scripting a regex parser for a single use case will often be simpler to get the job done, but is not scalable to a complex network (with its various and changing vendors/hw/versions) and thus &quot;not the right thing&quot;. But I have to react on some of the more precise points you made.</p>

<p>1/ XML and JSON are different in nature and both have pros and cons. I believe XML is better than JSON to serialize a complex router configuration, because its tree-like structure better maps a router configuration model, it supports namespaces (essential when dealing with native <em>and</em> IETF/openconfig models) and tag attributes: you can&#39;t even put metadata on a JSON object (&quot;dictionnary&quot;), unless by using a hack such as prepending a sub key/value with &quot;@&quot;.
Anyway, you&#39;d rather use XML than JSON with NETCONF, because the former was the initial serialization language, while a serious support for the latter came only later (and for the known problems you mentionned) (NB: note an intrisic argument, but a pragmatic one).</p>

<p>2/ Yes, if models are poorly structured/written and/or overly verbose, it will be a treasure hunt to find the proper request to get exactly the information you need (NB: no, chatgpt cannot do that, at least not for SROS), and yes it is easier to find it using show commands <strong>you already mastered</strong> and some regexes. You cannot work as comfortably with protocols and languages like NETCONF/XML/JSON/YANG than with show commands simply because the former were designed for machine-to-machine communication, while the latter is made for humans. You need tooling to work smartly with those automation things (parser, requester, explorers, request generator, etc.).</p>

<p>3/ A show command does not always have a Model-Driven equivalent because it might be a compilation of diverse elements put on a table for an operator to read with his eyes and process with his brain. Cf. my previous remark on machine-to-machine.</p>

<p>4/ Yes the IETF has biases, but HTTP/JSON/Python is not the only hammer out there ;-) Sure, HTTP/TLS could have been chosen instead of ssh. I guess people at the IETF (but also network engineer and techniciansi) were simply more familiar with ssh rather than HTTP, and back in 2006 (rfc4741) HTTP was not as ubiquitous as today. ssh still is ubiquitous for system and routers management though, and does not limit NETCONF.</p>

<p>Alternatively, gRPC-based protocols such as gNMI (NETCONF competitor) are based on HTTP2/TLS, and work with the same YANG models. BTW, protobufs (gRPC serialization format) is <a href="https://protobuf.dev/">compared</a> to &quot;XML, but smaller, faster, and simpler&quot; and <em>not</em> JSON... food for thoughts. Don&#39;t even mention RESTCONF, the REST hammer is not suited for the job (bye bye transactions).</p>

<p>5/ Yes, a vendor might make some breaking change to its YANG model while leaving its show command intact. That can be anticipated by reading the YANG changes (I agree that in some intricate models this is no simple task). The other way around, if the show command changes, good luck anticipating that: are you running some genAI to parse the vendor PDFs? it might not even be listed anywhere else than the developer post-it note.</p>

<p>6/ Yes, NETCONF/YANG borrow from SNMP/MIBs, but overcome many of their limitations, see rfc3535 for reference.</p>

<p>PS: Oops, sorry, made an extensive comment again... :-)
PS2: answering on the NAT articles soon.</p>
</div>
              <div class="comment-replies">
                <div class="comment-thread inline-thread">
                  <span class="thread-count"><a>Replies</a></span>
                    <ol>
      <div>
        <li class="comment" id="2631">
          <div class="comment-block">
            <div class="comment-header">
              <cite class="user"><a href="" rel="nofollow">Ivan Pepelnjak</a></cite>
              <span class="datetime secondary-text">
                <a rel="nofollow" id="c2631" href="#2631">13 May 2025 10:34</a>
              </span>
            </div>
            <div class="comment-content"><p>Hi Bob, thanks a million for such a detailed comment. Love it, and agree with quite a few things you wrote.</p>

<p>However, as much as I like XML (I&#39;m old enough to be using it before people started calling JavaScript objects JSON), you missed my point: it does not matter how good a technology is if people don&#39;t know how to use it, or if they&#39;re used to something else. VAX/VMS was the best operating system I&#39;ve seen, and I don&#39;t think anyone remembers what it was. It was just too different from what people were used to.</p>

<p>It&#39;s the same with XML/NETCONF and protobufs. It doesn&#39;t matter if they are orders of magnitude better than JSON/HTTP stuff if they&#39;re hard to use or unfamiliar to the people you can hire to get the job done. IETF insistence on using what <em>they</em> find convenient as opposed to what the consumers (= developers) prefer is just the icing on the cake (not to mention the irresistible urge to invent yet another schema language).</p>

<p>Just my cranky perspective after having to deal with way too many &quot;best&quot; technologies for a lifetime ;)</p>
</div>
          </div>
        </li>
      </div>
      <div>
        <li class="comment" id="2632">
          <div class="comment-block">
            <div class="comment-header">
              <cite class="user"><a href="" rel="nofollow">Bob</a></cite>
              <span class="datetime secondary-text">
                <a rel="nofollow" id="c2632" href="#2632">13 May 2025 02:25</a>
              </span>
            </div>
            <div class="comment-content"><p>Hi. I confess: I have a bias towards what I believe to be the best solution as opposed to the most easily available one. Sometimes I also feel like the IETF has a <em>not invented here</em> complex, and when some new ideas are discussed I do not see much effort into searching the already available tools and practices (I see the same phenomenom with my experienced colleagues who, for some, still consider they are <em>not</em> doing computer science, as opposed to network engineering... they built a templating engine and language less than 10 years ago... jinja2 anyone?!). History is full of (considered) better solutions eclipsed by more pragmatic and easy to start with alternatives (linux instead of the yet-to-come GNU hurd or many others, Python rather than lower level languages despite the generally poorer performance, not to mention the HTTP hegemony, to name a few).</p>

<p>XML might be considered old school, it is still hegemonous for documents serialization for example (I do not think there is a serious JSON equivalent of epub! might be wrong though). Protobufs and gRPC though, they are everywhere in k8s and other complex distributed systems, but rather on the &quot;backend side&quot;.</p>

<p>And yeah, never heard of VAX/VMS!</p>

<p>Cheers.</p>
</div>
          </div>
        </li>
      </div>
  </ol>

                </div>
              </div>
          </div>
        </li>
      </div>
      <div>
        <li class="comment" id="2644">
          <div class="comment-block">
            <div class="comment-header">
              <cite class="user"><a href="" rel="nofollow"> jo</a></cite>
              <span class="datetime secondary-text">
                <a rel="nofollow" id="c2644" href="#2644">27 May 2025 06:43</a>
              </span>
            </div>
            <div class="comment-content"><p>Hi.</p>

<p>imho the whole NETCONF ecosystem primarily suffers from a tooling problem. Or I haven&#39;t found the right tools yet.</p>

<p>ncclient is as you mentioned somewhere else an underdocumented mess. An that undocumented part is not even up to date (see https://github.com/ncclient/ncclient/issues/374#issuecomment-595092038) The commit-hash at the bottom of the docs page is from 2020...
I am amazed how so many people got it working good enough to depend on it in their applications.</p>

<p>The tools for browsing and inspecting YANG models is also not really there. Everything is abandoned. Cisco killed/abandoned 2 of their projects already. https://github.com/CiscoDevNet/yang-explorer is dead, and yangsuite fails to install, has outdated docs (https://developer.cisco.com/docs/yangsuite/welcome-to-cisco-yang-suite/#python-virtualenv-installation talks about Python 3.6 to 3.8, the README at https://github.com/CiscoDevNet/yangsuite is stuck at 3.9+ with 3.10 recommended, however installations fail for more modern versions. All the systems I am working on ship 3.11 or newer by default now. The docker container was also an insane amount of pain until it worked. And of course the code is not on github, the repo there is just a dummy repo for the docker container).
All I was looking for was a nice way to display what my device supports and to display and edit the values so that I can see what I am doing in a sea of XML</p>

<p>There have been a couple other tools that I have found which were dead even longer.</p>

<p>Am I missing some nice tool? What are people actually using to get things done with NETCONF?</p>
</div>
          </div>
        </li>
      </div>
  </ol>

    </div>
  </div>
</div>
