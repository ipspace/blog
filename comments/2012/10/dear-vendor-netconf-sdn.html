<div class="comments post" id="comments">
  <h4>3 comments:</h4>
  <div class="comments-content">
    <div class="comment-thread">
        <ol>
      <div>
        <li class="comment" id="7717291104619409833">
          <div class="comment-block">
            <div class="comment-header">
              <cite class="user"><a href="http://twitter.com/cmoberg" rel="nofollow">Carl Moberg</a></cite>
              <span class="datetime secondary-text">
                <a rel="nofollow" id="c7717291104619409833" href="#7717291104619409833">11 October 2012 12:24</a>
              </span>
            </div>
            <div class="comment-content">After sitting on my hands for a day I still can&#39;t resist the urge to bite :-) So, here are some reflections from the vantage point of a vendor to $vendors.<br /><br />First of all, the layering violation in the &quot;NETCONF != SDN&quot; phrase is... challenging. No, NETCONF envelopes around current CLIs (*cough*cisco*cough*) does not result in SDNishness. But that is, frankly, a little unfair to the protocol (NETCONF) and the modelling language (YANG). See, it would be trivial (but utterly pointless) to reimplement the OpenFlow protocol in NETCONF and YANG. Would such an exercise result in &quot;NETCONF == SDN&quot;?<br /><br />Perhaps another interesting approach to this is to look at the canonical uses cases that are proposed in SDNland. The recurring pattern is that they require access to features below (in terms of abstraction) what&#39;s exposed through SNMP and CLI in traditional systems. There is nothing in the protocol itself, of course, that stops $vendor development teams to expose lower-level APIs through it. It&#39;s more a side-effect of what (almost) all router and switch vendor software architectures look like. <br /><br />We&#39;re starting to see service provider teams and software developers warming up the potential power of this &quot;reliable Expect script&quot; (I&#39;ll let that rest for another blog post comment ;-) and are doing quite interesting things with it. As an example, there&#39;s a presentation on &quot;Network Configuration Management and Service Activation&quot; from NORDUnet available here (seems like the sound is gone for the first 5 mins): http://bit.ly/Vo2YMo No, this might not make it formally achieve SDNification, but it&#39;s an example of using software to program a NETCONF-enabled network.</div>
              <div class="comment-replies">
                <div class="comment-thread inline-thread">
                  <span class="thread-count"><a>Replies</a></span>
                    <ol>
      <div>
        <li class="comment" id="7969831834109593667">
          <div class="comment-block">
            <div class="comment-header">
              <cite class="user"><a href="https://www.blogger.com/profile/13457151406311272386" rel="nofollow">Ivan Pepelnjak</a></cite>
              <span class="datetime secondary-text">
                <a rel="nofollow" id="c7969831834109593667" href="#7969831834109593667">11 October 2012 21:34</a>
              </span>
            </div>
            <div class="comment-content">Carl, I agree with you that blaming NETCONF for the stupidities vendors do is the same as blaming HTTP for broken web sites. It would be fair to the NETCONF protocol to rephrase the heading into &quot;XML-encoded CLI using a well-defined namespace and delivered over SSH with a few extra characters != SDN&quot;, but then nobody would read it ;)<br /><br />However, based on how undefined SDN is, and how malleable to type-casting it is, it&#39;s probably comparable to anything, so my comparison is valid ;)<br /><br />The fact of life is (although both of us know better) that most people see NETCONF as &quot;configuration management tool&quot;. All implementations I&#39;ve seen so far use NETCONF as CLI replacement, and even the new drafts appearing in NETMOD working group focus on configuration aspects.<br /><br />While there&#39;s nothing that would stop NETCONF+YANG (or SOAP+XML+XSLT or REST+JSON or BGP+new-AF+communities or ...) from becoming a universal transport protocol, that&#39;s not how it&#39;s used today, and that&#39;s not what the SDNwashing marketing people are trying to sell us.<br /><br />As for the &quot;what can be done with NETCONF&quot; - I had a fully automated web-based customer provisioning system in 1993, and it included core router and access server configuration, so I know pretty well what CAN be done if someone decides to do it. Our FlipIT service is another good example - it auto-provisions everything from customer VMs to firewalls and Cisco Call Manager.<br /><br />However, yet again, even in those cases NETCONF is just a slightly more reliable transport protocol until the vendors actually implement things that are in NETMOD drafts 10 years after the NETCONF group was formed. I would call that glacial progress, but maybe I&#39;m still young and restless.</div>
          </div>
        </li>
      </div>
  </ol>

                </div>
              </div>
          </div>
        </li>
      </div>
      <div>
        <li class="comment" id="2785659333253905624">
          <div class="comment-block">
            <div class="comment-header">
              <cite class="user"><a href="http://www.dimitristheodorou.gr" rel="nofollow">Dimitris Theodorou</a></cite>
              <span class="datetime secondary-text">
                <a rel="nofollow" id="c2785659333253905624" href="#2785659333253905624">14 October 2012 13:35</a>
              </span>
            </div>
            <div class="comment-content">Well, does Nicira provide SDN? Because all they do with OpenFlow is to configure GRE tunnels, which might as well had been done with NETCONF. I mean, SDN is defined by seperating control from data, which can be done without using OpenFlow, but with just programing vendor-specific CLIs. Of course this can be a pain to implement and does not allow for programming forwarding tables and the potential that comes with it, but wouldn&#39;t you call it SDN?</div>
          </div>
        </li>
      </div>
  </ol>

    </div>
  </div>
</div>
