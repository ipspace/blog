---
date: 2013-03-26T07:32:00.000+01:00
tags:
- firewall
- security
- workshop
title: The Spectrum of Firewall Statefulness
url: /2013/03/the-spectrum-of-firewall-statefulness.html
---

<p>One of the first slides I created for the <a href="http://www.ipspace.net/Virtual_Firewalls">Virtual Firewalls</a> webinar explained various categories of traffic filters, from stateless (and fast) packet filters to application-level firewalls.</p>
<div class="separator"><a href="/2013/03/s1600-Firewall_Statefulness.png" imageanchor="1"><img border="0" src="/2013/03/s400-Firewall_Statefulness.png"/></a></div>
<p>As always, the real life is not black-and-white; I found a whole spectrum of products in the wild.<!--more--></p>
<p id="ACL">The well-known <strong>packet filters</strong> (or ACLs) are the bluntest of traffic filtering tools: they match (and pass or drop) individual packets based on their source and destination network addresses and transport layer port numbers. They keep no state (making them extremely fast and implementable in simple hardware) and thus cannot check validity of transport layer sessions or fragmented packets. </p>
<p>Some packet filters give you the option of permitting or dropping fragments based on network layer information (source and destination addresses), others either pass or drop all fragments (and sometimes the behavior is not even configurable).</p>
<p>Packet filters are easy to use in server-only environments. Life becomes interesting as soon as servers start establishing client sessions to other servers, and turns into hell in environments where clients establish ad-hoc sessions to random destination addresses.</p>
<p id="reverseACL"><strong>Packet filters with automatic reverse rules</strong> (example: XenServer vSwitch Controller) are a syntactic sugar on top of vanilla packet filters. Whenever you configure a filtering rule (example: permit inbound TCP traffic to port 80), the ACL configuration software adds a reverse rule in the other direction (permit outbound TCP traffic from port 80). </p>
<p id="establishedACL">ACLs that allow matches on <strong>established TCP sessions</strong> (typically matching TCP traffic with ACK or RST bit set) make your life a bit easier. In server-only environment you can use them to match inbound TCP traffic on specific port numbers and outbound traffic of established TCP sessions (to prevent simple attempts to establish outbound sessions from hijacked servers); in client-only environment you can use them to match return traffic.</p>
<p><strong>Reflexive access lists</strong> (Cisco IOS terminology) are the simplest stateful tool in the filtering arsenal. Whenever a TCP or UDP session is permitted by an ACL, the filtering device adds a 5-tuple matching the return traffic of that session to the reverse ACL.</p>
<p id="reflexiveACL">Reflexive ACLs generate one filtering entry per transport layer session. Not surprisingly, you won’t find them in platforms that do packet forwarding and filtering in hardware – they would quickly overload the TCAM (or whatever forwarding/filtering hardware the device is using), cause <a href="/2013/02/process-fast-and-cef-switching-and.html">packet punting to the main CPU</a> and reduce the forwarding performance by orders of magnitude.</p>
<p>Even though reflexive ACLs generate per-session entries (and thus block unwanted traffic that might have been permitted by other less-specific ACLs) they still work on individual packets and thus cannot reliably detect and drop malicious fragments or overlapping TCP segments.</p>
<p id="statefulFW"><strong>Transport layer session inspection</strong> combines reflexive ACLs with fragment reassembly and transport-layer validation. It should detect dirty tricks targeting bugs in host TCP/IP stacks like overlapping fragments or TCP segments.</p>
<p><strong>Application level gateways (ALG)</strong> add application awareness to reflexive ACLs. They’re usually used to deal with broken applications (<a href="/2010/05/ftp-trip-down-memory-lane.html">FTP</a>, SIP ...) that <a href="/2010/03/ftp-butterfly-effect.html">exchange transport session endpoints</a> (IP addresses and port numbers) in application payload – an ALG would detect the requests to open additional data sessions and create additional transport-level filtering entries.</p>
<p><strong>Web Application Firewalls</strong> (WAF) have to go way beyond ALGs. ALGs try to help applications get the desired connectivity and thus don’t focus on malicious obfuscations. WAFs have to stop the obfuscators; they have to parse application-layer requests like a real server would to detect <a href="http://xkcd.com/327/">injection attacks</a>. Needless to say, you won’t find full-blown WAF functionality in reasonably-priced high-bandwidth firewalls.</p>
<h4>Which tool should I use?</h4><p>As always, the universal answer is <em>It Depends</em>; for more details, read the <a href="/2010/08/i-dont-need-no-stinking-firewall-or-do.html"><em>I Don’t Need no Stinking Firewall</em></a>, <a href="/2010/08/to-waf-or-not-to-waf.html"><em>To WAF or not to WAF?</em></a><em> </em>and <a href="/2010/08/waf-musings-not-again.html"><em>WAF Musings</em></a> blog posts (they are almost three years old, but still pretty relevant).</p>

