---
date: 2009-08-24T06:49:00.002+02:00
tags:
- what went wrong
- Internet
title: 'What went wrong: the Socket API'
url: /2009/08/what-went-wrong-socket-api.html
---

<p>You might think that the <a href="https://blog.ipspace.net/2009/08/what-went-wrong-tcpip-lacks-session.html">lack of a decent session layer in the TCP/IP protocol suite</a> is the main culprit for our reliance on IP multihoming and <a href="https://blog.ipspace.net/2009/06/internet-anarchy-ill-advertise-whatever.html">related explosion of the IP routing tables</a>. Unfortunately, we have an even bigger problem: the <a href="http://en.wikipedia.org/wiki/Berkeley_sockets">Berkeley Socket API</a>, which is over 25 years old and used in almost all TCP/IP software implementations (including the high-level scripting languages like PERL).<!--more--></p>
<p class="update">Update 2016-07-08: gethostbyname is obsolete. Also added a reference to happy eyeballs which got popular after this blog post was written.</p>
<p>To establish a client-to-server connection using Socket API you have to perform these calls:</p>
<ul class="Bullet1"><li>Create a socket with the <a href="http://en.wikipedia.org/wiki/Berkeley_sockets"><em>socket()</em></a> call</li>
<li>Convert a hostname into a L3 address (IPv4 or IPv6) with the <a href="http://en.wikipedia.org/wiki/Getaddrinfo"><em>getaddrinfo()</em></a> or (obsolete) <a href="http://en.wikipedia.org/wiki/Berkeley_sockets"><em>gethostbyname()</em></a> call.</li>
<li>Connect to the remote L3 address with the <a href="http://en.wikipedia.org/wiki/Berkeley_sockets"><em>connect()</em></a><em> </em>call.</li>
</ul>
<p>The set of calls you have to perform is not surprising; Socket API is older than DNS. However, the reliance on L3 addresses passed around inside the application and a total disconnect between name resolution and session establishment is a disaster. </p>
<p>Just to give you an example: you might have a server farm offering a service (for example, <em>scs.msg.yahoo.com </em>or <em>www.X.google.com</em>) properly set up in DNS with numerous A records for the same name. However, most of the applications will perform the <em>getaddrinfo() </em>call which returns the list of addresses (regardless of whether they are reachable or not) and the first address (or all of them in sequence) is then usually passed to the <em>connect() </em>call (<a href="http://blog.ipspace.net/2013/03/happy-eyeballs-happiness-defined-by.html">happy eyeballs</a> implementations are an obvious exception). If the DNS lookup returned a temporarily unreachable IP address you’re doomed.</p>
<p class="note">When properly implemented, the <em>getaddrinfo() </em>call could return more than one address associated with the hostname … but <a href="http://forum.soft32.com/linux2/multi-homed-host-address-getaddrinfo-Options-ftopict40795.html">that’s not always the case</a>.</p>
<p>Obviously you could write better application code. You could make DNS calls yourself using the resolver library (or parse the information returned by <em>getaddrinfo()</em>), collect all IP addresses and try to connect to more than one of them. Telnet clients usually do that quite well. </p>
<p>You could even implement a connection-failure cache listing those addresses that were recently unreachable to speed up the future session setup process. But let’s be realistic: how many application programmers do you know that really understand the intricacies of TCP/IP (let’s lower the bar: how many of them could use the resolver library)? Most of them want to get their job done and end up using recipes from sources like <a href="http://www.linuxjournal.com/article/3237">Network Programming with Perl</a>.</p>
<p class="note">It looks like people writing Yahoo Messenger knew what they were doing; otherwise it wouldn’t make sense to have numerous A records for their IM servers.</p>
<p>The name-to-address mapping problem should have been abstracted into the OS kernel (or system library) decades ago (at the latest when DNS became widespread) and the applications should have been kept blissfully unaware of the complexities; the <em>connect() </em>call should accept a hostname and do the rest behind the scenes. Even Microsoft got that right with the NetBIOS API. But then, what could you expect: the Socket API is a direct mapping to the TCP/IP protocol stack (where DNS is just one of the applications).</p>
<p>With the sorry state of the Socket API, the best you can do if your service is reachable through multiple IP addresses is to randomize the DNS responses (this will give you some limited load sharing), adjust the list of A records in the DNS responses based on server availability (while hoping that the intermediate DNS servers or the clients will not ignore the TTL settings in the DNS responses) … and as the last resort make sure all the IP addresses are always reachable, which brings us back to where we’ve started: IP multihoming. You could also use a load balancer and a single (obviously multihomed) IP address.</p>

