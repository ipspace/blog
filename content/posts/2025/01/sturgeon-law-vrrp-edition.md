---
title: "Sturgeon's Law, VRRPv3 Edition"
date: 2025-01-23 08:37:00+0100
tags: [ IP routing, LAN ]
---
_I just wasted several days trying to figure out how to make the [dozen (or so) platforms](https://netlab.tools/module/gateway/) for which we implemented VRRPv3 in [netlab](https://netlab.tools/) work together. This is the first in a series of blog posts describing the [ridiculous stuff](https://en.wikipedia.org/wiki/Sturgeon%27s_law) we discovered during that journey_

The idea was pretty simple:

* Create a lab with the tested device and a well-known probe connected to the same subnet.
* Disable VRRP (or interface) on the probe and check IPv4 and IPv6 connectivity through the tested device (verifying it takes over ownership of VRRP MAC and IP addresses).
* Reenable VRRP on the probe and change its VRRP priority several times to check the state transitions through INIT/BACKUP(lower priority)/MASTER(change in priority)/BACKUP(preempting after a change in priority).
<!--more-->
When using an Arista EOS VM as the well-known probe, I discovered that it refuses to yield to a preempting attempt from numerous other devices (for example, Cisco IOS or Cisco Nexus OS) *for the IPv4 address family*[^BFD]. The same devices preempted EOS *for the IPv6 address family*.

[^BFD]: I also failed to detect that Arista EOS quickly switched to MASTER state even if the other VRRP router had higher priority because it showed the initial VRRP state as BACKUP. I should have waited a few seconds for the VRRP dust to settle.

Having two (or more) VRRP masters on the same segment cannot be good. If nothing else, you might get *duplicate MAC address* or *flapping MAC address* messages on adjacent L2 switches, so it was time to figure out what was happening. I used **tcpdump** to see the VRRP packets and noticed the `bad vrrp cksum` diagnosis for the VRRP packets sent by Cisco IOS:

{{<cc>}}VRRPv3 packet sent by EOS seems OK; the one from Cisco IOS has a checksum error{{</cc>}}
```
07:56:11.666890 00:00:5e:00:01:d9 (oui IANA) > 01:00:5e:00:00:12 (oui Unknown), ethertype IPv4 (0x0800), length 46: (tos 0xc0, ttl 255, id 1, offset 0, flags [none], proto VRRP (112), length 32)
    172.16.0.1 > vrrp.mcast.net: VRRPv3, Advertisement, vrid 217, prio 30, intvl 100cs, length 12, addrs: 172.16.0.42
07:56:11.743555 00:00:5e:00:01:d9 (oui IANA) > 01:00:5e:00:00:12 (oui Unknown), ethertype IPv4 (0x0800), length 60: (tos 0xc0, ttl 255, id 0, offset 0, flags [none], proto VRRP (112), length 32)
    172.16.0.2 > vrrp.mcast.net: VRRPv3, Advertisement, vrid 217, prio 20, intvl 100cs, length 12, (bad vrrp cksum d87), addrs: 172.16.0.42
```

Likewise, Cisco IOS complained that the packets generated by Arista EOS contain invalid checksum:

```
r2#debug vrrp packet
vrrp packet debugging enabled
r2#
*Jan 22 08:57:27.239: VRRPv4 Ethernet0/1 [217] vrrpv3 chksum D87
*Jan 22 08:57:27.239: VRRPv4 Ethernet0/1 [217] Send V3 Advertisement, Type: 1, Group Id: 217, Priority: 20, Advert interval: 100 csec, Count: 1
*Jan 22 08:57:27.806: VRRP Ethernet0/1 Processing Packet:Invalid checksum Calculated chksum is nonzero (8CA0), Packet chksum is (76E6)
```

At that moment, I decided it was high time for another journey into the RFC land. VRRPv3 is defined in [RFC 5798](https://datatracker.ietf.org/doc/html/rfc5798), which is obsoleted by [RFC 9568](https://datatracker.ietf.org/doc/html/rfc9568) from April 2024. The latter RFC contains an interesting [change from the RFC 5798](https://datatracker.ietf.org/doc/html/rfc9568#name-differences-from-rfc-5798):

> The checksum calculation in Section 5.2.8 has been clarified to specify precisely what is included and that it does not include the pseudo-header for IPv4.

That section is [even more interesting](https://datatracker.ietf.org/doc/html/rfc9568#sect-5.2.8):

* For IPv4 messages, the checksum includes only the VRRP message.
* For IPv6, the checksum includes the pseudo-header.

To recap:

* The wording in RFC 5798 was vague, referring to *pseudo-header* being included in the checksum calculation.
* There is no *pseudo-header* in IPv4.
* VRRPv3 implementations assumed either (A) ignore that wording as there is no *pseudo-header* in IPv4 or (B) create *pseudo-header* for IPv4 out of thin air (OK, using the rules from [IPv6 RFC](https://datatracker.ietf.org/doc/html/rfc2460#section-8.1)).
* Arista EOS and FRR seem to be the implementations using the *let's fake the pseudo-header* approach, while most others adopted the *there is no pseudo-header in IPv4* mentality.
* Most VRRP implementations ignore packets with incorrect checksum, potentially resulting in two VRRP masters on the same segment in multi-platform deployments.
* RFC 5798 was published in 2010, and the first implementations appeared in the early 2010s, yet some vendors or open-source projects seem to have skipped the interoperability tests with other platforms.
* The early implementations[^J122] used the same *there is no pseudo-header in IPv4* approach, leaving one to wonder how we arrived at the two interpretations of the RFC (and how the minority interpretation made it into **tcpdump**).

[^J122]: The Junos release 12.2 in May 2012, and the Cisco IOS release 15.3 in early 2013

Finally:

* Dell OS10 takes a particularly creative approach: it switches to the checksum calculation used by the other VRRP device.

Fortunately, you can make Arista EOS RFC 9568-compliant with the **â€Œvrrp ipv4 checksum pseudo-header exclude** configuration command, and FRR has **no vrrp checksum-with-ipv4-pseudoheader** command since [late 2022](https://github.com/FRRouting/frr/pull/12390).

However, as is often the case, downstream distros can take a long time to pick up the changes. Cumulus Linux release 5.10 still uses an older FRR version, and the current (as of January 2025) VyOS Vagrant box (v20240817.00.20) has no nerd knob to configure the underlying FRR VRRP process.
