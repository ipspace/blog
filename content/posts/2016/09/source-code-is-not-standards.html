---
url: /2016/09/source-code-is-not-standards.html
title: "Source Code Is Not Standards"
date: "2016-09-14T07:55:00.000+02:00"
tags: [ SDN,Internet ]
---

<p><a name="_GoBack"></a>One of the oft-repeated messages of the Software-Defined Pundits is “<em>Standard bodies are broken, (open) source code is king</em>”… and I’d guess that anyone who was too idealistic before being exposed to how the sausage is being made within IETF has no problems agreeing with them. However…<!--more--></p>
<p>One of the benefits of a standards process is that (sometimes) you have to think before you start coding your solution, and while IETF often acts like <a href="https://archive.psg.com/051000.sigcomm-ivtf.pdf">Internet Vendor Task Force</a>, the IETF process at the very minimum gets your ideas exposed to people with different perspectives or opposing ideas, potentially resulting in either better standards or religious debates (<a href="http://www.gossamer-threads.com/lists/engine?do=post_view_flat;post=180509;list=nanog">DHCPv6 versus RDNSS</a> or /48-for-everyone being my favorites).</p>
<p>Nothing like that could be said for let’s-get-this-coded approach. I’ve seen large open-source projects that were fantastic from both architectural and implementation perspective, and other open-source projects that were a total mess that made spaghetti Bolognese look as ordered as diamond crystal lattice. How about early Neutron plugins that used CLI commands to install flows periodically pulled down from MySQL database into local Open vSwitch.</p>
<p>Then there’s the “code is self-documenting” approach promoted by people who don’t think <a href="https://blog.ipspace.net/2015/10/we-need-product-documentation-not-just.html">documenting their work is important</a> (there are obvious exceptions, like the RSX-11M operating system, where half of the source code real estate was devoted to comments explaining in high-level terms what’s going on in the code). However, having “self-documenting” source code potentially available at your fingertips is not exactly helpful when your LibreOffice client fails to format simple Word document correctly… and there aren’t many users who have the knowledge necessary to fix the problem (let alone the time).</p>
<p>Networking is no different. Even if you get the source code of a broken product, most networking teams have no chance to fix it… and don’t forget that “open” networking (for some value of “open”) is all about having multiple interoperable implementations. While standards used to get those implementations might be imperfect, reverse-engineering someone else’s code to get the protocol on the wire is as wrong as it can get. </p>
<p>When you’re trying to troubleshoot a network-down problem at 3AM on Sunday night digging through the code is not the answer – you <a href="https://blog.ipspace.net/2015/03/you-must-understand-fundamentals-to-be.html">MUST understand how things work</a>, and the only way to get there is proper documentation.</p>
<p class="note">Believers in open source will obviously disagree with me, but as long as you don’t have a documented protocol, and only a single implementation, you might as well call that code <em>proprietary </em>(see <a href="https://en.wiktionary.org/wiki/proprietary">definition #4 in this Wiktionary article</a>).</p>
<p>Oh, and even if you don’t believe in multiple interoperable implementation, you might still want to troubleshoot the stuff that’s going on between network nodes with something like Wireshark, and having no protocol specification makes writing the decoder an extremely fun task.</p>
<h4>Now what?</h4><p>Honestly, I don’t have a clear answer. IETF is slow (and cumbersome for someone who is not paid to sit on a standards body and just tries to get the job done), and relying on open-source code alone can result in a <a href="https://blog.ipspace.net/2016/04/open-source-software-could-have-great.html">nicely documented product</a> or a hard-to-fix mess (remember <a href="#Forks">OpenSSL</a>?). Is there a third way? Share your opinion in the comments!</p>

