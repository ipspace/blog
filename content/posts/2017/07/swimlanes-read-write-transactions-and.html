---
url: /2017/07/swimlanes-read-write-transactions-and.html
title: "Swimlanes, Read-Write Transactions and Session State"
date: "2017-07-04T08:12:00.000+02:00"
tags: [ Design,Data Center,WAN ]
---

<p>Another question from someone watching my <a href="http://www.ipspace.net/Designing_Active-Active_and_Disaster_Recovery_Data_Centers"><em>Designing Active-Active and Disaster Recovery Data Centers</em></a> webinar (you know, the one where I tell people how to avoid the world-spanning-layer-2 madness):</p>
<blockquote class="cite">In the video about parallel application stacks (swimlanes) you mentioned that one of the options for using the R/W database in Datacenter A if the user traffic landed in Datacenter B in which the replica of the database is read-only was to redirect the user browser with the purpose that the follow up HTTP POST land in Datacenter A.</blockquote>
<p>Here’s the diagram he’s referring to:<!--more--></p>
<div class="separator"><a href="/2017/07/s1600-AA-Redirects.jpg" imageanchor="1"><img border="0" src="/2017/07/s550-AA-Redirects.jpg"/></a></div>
<p>Just in case you’re wondering why someone would go for an architecture that seems complex: several people running e-commerce sites told me that they see more than 99% of read-only transactions. Also, expecting to get transactional consistency across multiple active-active data centers is a recipe for disaster (see also: <a href="https://en.wikipedia.org/wiki/CAP_theorem">CAP theorem</a>).</p>
<p class="note">A major difference between an application-layer solution and stretched VLANs is that in one case you own the complexity and can thus manage it. </p>
<p>Continuing with the question…</p>
<blockquote class="cite">In that case wouldn't the Web/App servers in Datacenter A need to know the session already created for the user in Datacenter B Web/App servers?</blockquote>
<p>Absolutely. They would need to:</p>
<ul class="ListParagraph"><li>Recognize the session cookie (so the user doesn’t have to log in again) or use some other mechanism to authenticate user based just on user-supplied information (see <a href="https://en.wikipedia.org/wiki/Kerberos_(protocol)">Kerberos</a>);</li>
<li>Have access to the data needed for R/W transaction.</li>
</ul>
<p>I would probably use an eventually consistent database (MongoDB, for example) to solve the second challenge, and assume that the user data (for example, shopping cart) arrives to DC-A before the user clicks the "Purchase" button. I would also put some simple checksum (or calculate a hash) of the data to verify it got there, or start the checkout process (<em>review your shopping cart </em>phase) in DC-A. Alternatively, you could process all “add to basket” transactions in DC-A so the data is already there (shipping a copy to DC-B in case DC-A fails).</p>
<p class="note">In any case, if the user arrives into DC-A before the data does, you have a serious communication problem between DC-B and DC-A, and it’s time to admit the failure.</p>
<p>Long story short: </p>
<ul class="ListParagraph"><li>Try to make your solution <a href="http://quoteinvestigator.com/2011/05/13/einstein-simple/"><em>as simple as possible, but not simpler</em></a>;</li>
<li>Solve the complexity on the application layer considering all potential failure scenarios (including <em>user can see DC-A and DC-B, but they can’t see each other</em>)</li>
<li>Recognize that distributed systems always involve <a href="https://en.wikipedia.org/wiki/Byzantine_fault_tolerance">byzantine failures</a> (see also <a href="https://c3.nasa.gov/dashlink/static/media/other/ObservedFailures1.html">this NASA document</a>) and that sometimes the best thing you can do is to admit the failure to the user and ask her to recover instead of failing in obscure and undocumented ways.</li>
</ul>
<p>Have you learned something new? Guess how much more you’d learn in <a href="http://www.ipspace.net/Building_Next-Generation_Data_Center">Building Next-Generation Data Center</a> online course ;)</p>

