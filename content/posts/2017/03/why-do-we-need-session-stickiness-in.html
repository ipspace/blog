---
date: 2017-03-22T08:17:00.000+01:00
tags:
- data center
- load balancing
title: Why Do We Need Session Stickiness in Load Balancing?
url: /2017/03/why-do-we-need-session-stickiness-in.html
---

<p><a name="_GoBack"></a>One of the engineers watching my <a href="http://www.ipspace.net/Data_Center_3.0_for_Networking_Engineers">Data Center 3.0 webinar</a> asked me why we need session stickiness in load balancing, what its impact is on load balancer performance, and whether we could get rid of it. Here’s the whole story from the networking perspective.<!--more--></p>
<p class="update">Update 2017-03-22: Added link to PROXY protocol which can be used to pass original client IP address to a web server even when SSL connection is terminated on the web server.</p>
<h4>What Is (Network) Load Balancing?</h4><p>Load balancing is one of the dirty tricks we have to use because <a href="https://blog.ipspace.net/2009/08/what-went-wrong-tcpip-lacks-session.html">TCP doesn’t have a session layer</a> (yes, I had to start there). It allows a farm of servers to appear to the outside world as a single IP address.</p>
<div class="separator"><a href="/2017/03/s1600-LB_Basics.png" imageanchor="1"><img border="0" src="/2017/03/s550-LB_Basics.png"/></a></div>
<p>There are numerous ways to make this trick work; the most common one involves network address translation (even in IPv6 world)</p>
<p>Whenever a client tries to open a new session with the shared (aka outside or virtual) IP address, the load balancer decides which server to use to serve the client, opens a TCP session to the selected server, and creates a NAT translation entry translating TCP session to virtual IP address into a TCP session to server’s real IP address.</p>
<div class="separator"><a href="/2017/03/s1600-LB_NAT.png" imageanchor="1"><img border="0" src="/2017/03/s550-LB_NAT.png"/></a></div>
<p>In this scenario the return traffic MUST pass through the load balancer – the load balancer is the only point in the network that knows how to translate the “inside” TCP session into the “outside” TCP session. </p>
<p>You can use routing to push the return traffic through the load balancer (load balancer is the default gateway for the server farm) or source NAT where the source IP address of the original client is replaced with the load balancer’s IP address, ensuring the return traffic always goes through the load balancer.</p>
<p class="warn">Source NAT hides client’s real IP address from the servers, making it impossible to use geolocation or IP address-based actions (like user banning). A load balancer could insert the client’s real IP address into the <strong>X-forwarded-for </strong>HTTP header, which obviously doesn’t work if you want to use TLS (aka SSL) all the way to the web servers.<ins> You can, however use the <a href="http://git.haproxy.org/?p=haproxy.git;a=blob_plain;f=doc/proxy-protocol.txt;hb=HEAD">PROXY protocol</a> in that case assuming your web server supports it</ins> (thanks to Lukas Tribus for pointing that out).</p>
<p class="more">Want to know more about load balancing mechanisms, from application-level to anycast and network appliance approaches? You’ll find them all in the <a href="http://www.ipspace.net/Data_Center_3.0_for_Networking_Engineers">Data Center 3.0 webinar</a>.</p>
<h4>What Are HTTP Sessions?</h4><p>HTTP (in all its versions) has a fundamental problem: it’s stateless. Every single request sent by the client is totally independent and not linked to the previous requests, making it impossible to implement web site logins, shopping carts…</p>
<p>Well, since all the features I mentioned in the previous paragraph work, there must be another trick involved: HTTP sessions implemented with specially-crafted URLs or session cookies:</p>
<ul class="ListParagraph"><li>Whenever a new client visits a web site, the web server creates a session for the new client, and sends the session identifier (usually in an HTTP cookie) to the client;</li>
<li>As the web server processes client requests, it stores per-client state (username, preferences, shopping cart contents…) in session variables. These session variables are automatically saved by the web server and restored when the client makes the next request based on client’s session cookie.</li>
</ul>
<h4>What Are Sticky Sessions?</h4><p>Using the default configuration many scripting languages (including PHP) save session data in temporary files residing on the web server. The client session state is thus tied to a single web server, and all subsequent client requests must be sent to the same server – the HTTP sessions must be <strong>sticky</strong>.</p>
<p>The load balancer could implement session stickiness using additional session cookies generated by the load balancer or by caching the mapping between client IP addresses and web servers.</p>
<p>In the old days of short-lived HTTP sessions, the state generated by session stickiness was a major nightmare – the number of clients that had to be cached was an order of magnitude (or more) larger than the number of active HTTP sessions.</p>
<p>With persistent HTTP connections the difference between the number of active TCP sessions and the number of clients probably becomes negligible (or at least smaller). Would appreciate real-life data points; please write a comment.</p>
<p class="more">Want to know what persistent HTTP connections are? I explained them in the free <a href="http://www.ipspace.net/TCP,_HTTP_and_SPDY">TCP, HTTP and SPDY</a> webinar.</p>
<h4>Do We Need Sticky Sessions?</h4><p>Short answer: NO!</p>
<p>Every web server scripting environment I looked at has a mechanism to store client session data in data store shared among all servers, making session stickiness totally unnecessary. Using a shared data store any web server can retrieve the client session data on demand, so there’s no need for load balancer to track client-to-server mappings. </p>
<p class="update">Added 2017-03-28: Some readers understood the <em>shared data store</em> to mean transactional database like MySQL. You should use a solution that meets your consistency requirements – in most cases <em>memcached</em> is more than good enough.</p>
<p>The only reason the scripting languages (PHP, Python…) store session data on the local web server (most often in the local file system) is because the local file system is always available and thus requires no configuration – the installation will work even when the web server admin can’t read.</p>
<p>To make matters worse: it takes one or two lines of web server configuration to enable the shared data store, but because “it cannot be done” in many cases the networking team buys yet another expensive load balancer giving CIO another reason to complains about the costs of data center networking.</p>
<h4>Even More Load Balancing</h4><p>I described how you can use load balancing to implement active/active data centers in <a href="http://www.ipspace.net/Designing_Active-Active_and_Disaster_Recovery_Data_Centers">Designing Active/Active Data Centers</a> webinar, and Ethan Banks described his hands-on experience in <a href="http://nextgendc.ipspace.net/Public:5-High-Availability_Concerns">autumn 2016 session</a> of the <a href="http://www.ipspace.net/Building_Next-Generation_Data_Center">Building Next-Generation Data Center webinar</a> (you get access to recordings of autumn 2016 session as soon as you <a href="http://www.ipspace.net/Building_Next-Generation_Data_Center#register">register</a>).</p>

