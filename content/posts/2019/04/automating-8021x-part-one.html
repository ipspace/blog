---
date: 2019-04-15T07:54:00.000+02:00
tags:
- automation
- Ansible
title: Automating 802.1x (Part One)
url: /2019/04/automating-8021x-part-one/
---

<p><em>This is a guest blog post by <a href="https://www.linkedin.com/in/albertsiersema/">Albert Siersema</a>, senior network and cloud engineer at Mediacaster.nl. He’s always busy broadening his horizons and helping his customers in (re)designing and automating their infrastructure deployment and management.</em></p>
<hr/><p>We’d like to be able to automate our network deployment and management from a <a href="/2019/03/building-network-automation-source-of/">single source of truth</a>, but before we get there from a running (enterprise, campus!) network, we’ll have to take some small steps first.</p>
<p>These posts are not focused on 802.1x, but it serves as a nice use case in which I’ll show you how automation can save time and bring some consistency and uniformity to the network (device) configuration.<!--more--> Having consistent device configurations might not be the sexiest side of automation, but it gets the job done and prepares your environment for more automation coolness later. Also, let’s face it: if you need to reconfigure hundreds of switches and tens of thousands of interfaces, automation literally saves (the) day(s).</p>
<p>Implementing 802.1x (after talking to all parties involved) enables us to convert a switch, location and interface specific configuration into a more generic configuration where specific items get pushed to the switch from a central RADIUS server (e.g. Cisco ISE), which also serves as a single source of truth describing user-specific information.</p>
<p>You can find the Ansible playbooks I’m describing in this blog post on <a href="https://gitlab.com/thefriendlynet/ansible_automation/8021x">gitlab</a>. The 802.1x playbooks where used with Catalyst switches running Cisco IOS, but shouldn’t be too complicated to adapt to other vendors/models.</p>
<p>The playbooks follow a similar setup:</p>
<ul><li>Gather information (from the source of truth or lacking that, the switch).</li>
<li>Apply changes.</li>
<li>Validate changes: does the current active state match the desired state (or intent if you like).</li>
</ul>
<h3 id="first-off-configure-vlan-group-names">First off: configure VLAN group names</h3><p>Unless you’re lucky and every switch is already a small L2 domain with L3 boundaries and the same VLAN numbers are reused everywhere, you’re going to need named VLAN groups that a RADIUS server can use to push information to the switch. After receiving information from the RADIUS server, the switch in turn decides which VLAN numbers to apply the information to based on the VLAN group name it received.</p>
<p>Chances are these VLAN groups are not yet configured on all your switches, so we’ll automate configuring the required VLAN groups everywhere as our first automation step.</p>
<p>Software running on most campus switches is still struggling with the idea of exchanging well-formed structured data, so a large part of any network automation solution still centers around building the right sequences of CLI commands and parsing command outputs pretty-printed for humans.</p>
<p>Using Ansible to create and verify VLAN groups is no exception. We have to:</p>
<ul><li>Gather information: pull a list of VLANs from the switch by parsing the output of the <strong>show vlan</strong> command (lacking a single source of truth, we have to depend on the configurations of individual switches) to get VLAN IDs and names.</li>
<li>Build configuration commands and apply changes: build VLAN group configuration commands to apply the changes.</li>
<li>Validate: parse the output of the <strong>show vlan group</strong> command to see if our changes have been applied the way we intended.</li>
</ul>
<p>Some points of possible interest:</p>
<ul><li>I use a <strong>which_hosts</strong> variable with a sensible default in the <strong>hosts</strong> parameter of Ansible plays. This trick enables me to specify a different Ansible inventory group from the command line using for example <code>-e "which_hosts='other_group'"</code></li>
<li>Playbook arguments that can be specified as external variable (<code>-e</code> CLI parameter) are defined and documented in a vars file with the same filename as the playbook.</li>
<li><strong>parse_cli()</strong> is used to hammer the show command output into structured data. It’s an extremely handy filter, and if you haven’t used it yet, be sure to give it a try.</li>
<li>The Cisco CLI command syntax isn’t always consistent. There are no <em>add</em> or <em>remove</em> commands for VLAN groups like there are for 802.1q trunk VLAN lists, so we have to remove all VLANs from a previously-defined VLAN group before we can start modifying it. To make matters worse, not all Cisco switches accept the 1-4095 VLAN range, so we need to try two versions of the <strong>no</strong> command.</li>
</ul>
<p class="note">Mind you, as a consequence of classic Cisco IOS not supporting transactions, we’re facing a potential race condition: if an interface is to be configured with the VLAN ID from a VLAN group at the same time as we’re in the middle of removing and re-adding a (previously present) VLAN group, the VLAN assignment for that interface might fail. A possible workaround is to check which switches are missing the VLAN group we’re configuring (use <code>--check</code> with this very same playbook), then only apply the changes to these switches.</p>
<ul><li>I had to build a list of individual VLAN group commands listing every individual VLAN IDs as it seems that using the Cisco number range syntax in Ansible confuses the Cisco IOS versions I used the playbook with.</li>
</ul>
<p class="note">I’ve not yet discovered exactly why, but it seems that a comma in the range command causes the configuration command sent by Ansible <strong>ios_config</strong> module to fail. </p>
<ul><li>To validate the <strong>show vlan group</strong> output, we need to convert the list of VLAN IDs back into a number range. I failed to find a suitable filter, wrote my own custom Jinja2 filter, and then (when looking for something unrelated) discovered a VLAN range filter called <strong>vlan_compress</strong> in the sources of <a href="https://github.com/ansible-network/network-engine">Ansible network engine</a>. Although the network engine github page states they like you to use it as a foundation for building your own Ansible role, it’s not a problem to specify the core network engine as a role to be able to use <strong>vlan_compress()</strong></li>
</ul>
<h4 id="using-the-playbook">Using the playbook</h4><p>The playbook expects these parameters that can be specified either in a group variable file or with the <code>-e</code> CLI parameter:</p>
<ul><li><em>search_vlan_pattern</em> : a regular expression specifying which VLANs we want to put have in the VLAN group</li>
<li><em>vlan_group_name</em>: name of a VLAN group we’re creating. The VLAN group will contain a list of IDs for all configured VLANs matching the <em>search_vlan_pattern</em> regular expression.</li>
</ul>
<p>Example: assuming our VLAN names are case-insensitive names optionally starting with one or two letters, followed by one or more digits, followed by zero or more letters, a dash, the string ‘voip’, again a dash and one or more digits (like b22a-voip-555 or 22-VoIP-555 or b22-VOIP-555) we could use the regular expression <code>(?i)^([a-z]{1,2})?\d+\w*-voip-\d+</code></p>
<p><strong>Compliance check or dry-run</strong> to discover which switches need changes: run the playbook in <em>check</em> mode, for example:</p>
<pre><code>ansible-playbook vlan_group.yaml --check -v \<br/>  -e "search_vlan_pattern='(?i)^([a-z]{1,2})?\d+\w*-voip-\d+'" \<br/>  -e "vlan_group_name='DATA'"</code></pre><p><strong>Make configuration changes</strong>. You might decide to apply changes to a subset of switches. To do that, you could filter out the switches that need changes, create a new group in your Ansible inventory, and apply changes to switches in that particular group by setting the <em>which_hosts</em> extra variable:</p>
<pre><code>ansible-playbook vlan_group.yaml -e "which_hosts='change_these'" \<br/>  -e "search_vlan_pattern='(?i)^([a-z]{1,2})?\d+\w*-voip-\d+'" \<br/>  -e "vlan_group_name='DATA'"</code></pre><div class="note" data-markdown="1">If you have to fix just a few switches, it’s easier to use the <code>--limit</code> CLI parameter. </div>
<p><strong>Configuring a VLAN group with fixed VLAN ID</strong>: If you don’t want to extract VLAN IDs from existing VLAN names but want to configure a VLAN group with a fixed VLAN ID everywhere, and if you don’t care whether the switches already have ports in target VLAN, use <strong>force_vlan_id</strong> extra variable to specify the target VLAN ID, and set <strong>only_vlans_with_configured_ports</strong> variable to <strong>false</strong>.</p>
<pre><code>ansible-playbook vlan_group.yaml \<br/>  -e "force_vlan_id=705" \<br/>  -e "vlan_group_name='VG_705'" \<br/>  -e "only_vlans_with_configured_ports=false"</code></pre><h4 id="bonus-trick">Bonus trick</h4><p>You might like the bash script <strong><a href="https://gitlab.com/thefriendlynet/ansible_automation/8021x/blob/master/filter_playbook_output.bash">filter_playbook_output.bash</a></strong> in the gitlab repo. It cleans up the output of the Ansible playbook.</p>
<p>The script assumes you’re using the YAML stdout callback. You can specify the stdout callback in your <strong>ansible.cfg</strong> file:</p>
<pre><code>[defaults]<br/>stdout_callback = yaml<br/>bin_ansible_callbacks = True</code></pre><p>Alternatively, you could use Ansible environment variables:</p>
<pre><code>export ANSIBLE_STDOUT_CALLBACK=yaml<br/>export ANSIBLE_BIN_ANSIBLE_CALLBACKS=1</code></pre><p>If you store the printout of your Ansible playbook into a file using either <strong>tee</strong> stdout redirection or <code>ANSIBLE_LOG_PATH</code> variable you can use <a href="https://gitlab.com/thefriendlynet/ansible_automation/8021x/blob/master/filter_playbook_output.bash">this script</a> to show the relevant portions of the output:</p>
<h4 id="finishing-notes">Finishing notes</h4><p><strong>parse_cli()</strong> might miss some information because we’re forced to screen scrape command output formatted for human consumption.</p>
<p>The default line width on most switches is 80 columns and while Ansible tries to set the width to 512 columns (assuming the Cisco IOS version running on the switch supports that) <strong>parse_cli()</strong> might still miss items if the line length exceeds 512 characters which could easily happen if you have more than approximately 60 interfaces in one VLAN. I’ve submitted <a href="https://github.com/ansible/ansible/issues/53277">a fix</a> which the Ansible team merged into upcoming Ansible 2.8 release.</p>
<h4 id="git-repo">Git repo</h4><p><a href="https://gitlab.com/thefriendlynet/ansible_automation/8021x">thefriendlynet/ansible_8021x</a></p>
<h4 id="more-information">More Information</h4><p>Want to implement something similar in your environment? You’ll learn all you need to know about Ansible in <a href="https://ipspace.net/Ansible">Ansible for Networking Engineers</a> webinar or online course, and get all the knowledge and skills you need to build your own network automation solution in our <a href="https://www.ipspace.net/Building_Network_Automation_Solutions">Building Network Automation Solutions online course</a>.</p>

